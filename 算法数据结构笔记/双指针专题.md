## 初步介绍

### 提高coding quality十二则

#### coding style相关

- 二元运算符两边加空格；单元运算符不加空格
- 花括号和for、if之间要加空格；圆括号与if之间要加空格
- 用空行分隔开不同的逻辑块
- 逗号后面加空格

#### readability相关

- 函数名变量名用1-2个单词作为名称
- 确保一个函数内部不超过三层缩进
- 多用子函数来减少入口函数的代码量
- 多用continue；少用if

#### bug free相关

- 入口函数的参数需要进行异常检测
- 访问下标时确保下标不越界
- 访问对象的属性或方法时确保对象不为空
- 不用全局变量



### 引子：最长回文子串

一个字符串abcd，先介绍两个概念

- 子序列：非连续的字符，有2^n种
- 子串：连续字符，有n^2种

回文子串：形如aba、abba这种就是回文子串

怎样检测一个字符串是否含有回文子串，可以用双指针

> 解决回文子串的最优算法就是Manacher algorithm算法，但面试中一般不会适合用这个，背诵题

#### 基于中心点枚举的方法求解

基本思想是：从一个子字符串的中心开始遍历，如果中心不是回文的，那以这个为中心的所有字符串都不可能是回文子串。这样就可以减少判断开销，直接跳到下一个中心继续寻找，算法时间复杂度 O(n^2)。

```java
public class Solution {
    public static void main(String[] args) {
        String str = longestPalindrome("abccbaaaq");
        System.out.println(str);
    }

    public static String longestPalindrome(String str) {
        if (str == null || str.length() == 0) {
            return "";
        }
        int start = 0, len = 0, longest = 0;
        for (int i = 0; i < str.length(); i++) {
            len = findLongestPalindromeFrom(str, i, i);
            if (len > longest) {
                longest = len;
                start = i - len / 2;
            }
            len = findLongestPalindromeFrom(str, i, i+1);
            if (len > longest) {
                longest = len;
                start = i - (len / 2) + 1;
            }
        }
        return str.substring(start, start + longest);
    }
    
    public static int findLongestPalindromeFrom(String s, int left, int right) {
        int len = 0;
        while (left >= 0 && right < s.length()) {
            if (s.charAt(left) != s.charAt(right)) {
                break;
            }
            len += left == right ? 1 : 2;
            left--;
            right++;
        }
        return len;
    }
}
```



#### 基于区间型动态规划的方法求解

区间型动态规划的思想：对于一个回文串，它的左右各减一个字符的子串任然是回文串。

确定状态：构建一个n*n的boolean数组，用来表示i到j是否为回文子串。

转移方程：i到j为回文串 = (i+1到j-1为回文串) && (字符i==字符j)

初始条件：任何一个字符都是长度为1的回文串，此外还需找到长度为2的回文串，这两种情况就是初始条件

```java
public class Solution {
    public static void main(String[] args) {
        String str = longestPalindrome("abccbaaaq");
        System.out.println(str);
    }

    public static String longestPalindrome(String str) {
        if (str == null || str.length() == 0) {
            return "";
        }
        int n = str.length();
        boolean[][] isPalindrome = new boolean[n][n];

        // 设定初始值
        int longest = 1, start = 0;
        for (int i = 0; i < n; i++) {
            isPalindrome[i][i] = true;
        }
        for (int i = 0; i < n - 1; i++) {
            isPalindrome[i][i + 1] = str.charAt(i) == str.charAt(i + 1);
            if (isPalindrome[i][i + 1]) {
                start = i;
                longest = 2;
            }
        }
		
        // 之所以这里从后往前，是因为初始化结束后，start是指向最后一个二回文子串
        for (int i = n - 1; i >= 0; i--) {
            for (int j = i + 2; j < n; j++) {
                // 转移方程
                isPalindrome[i][j] = isPalindrome[i + 1][j - 1] &&
                        str.charAt(i) == str.charAt(j);
                if (isPalindrome[i][j] && j - i + 1 > longest) {
                    longest = j - i + 1;
                    start = i;
                }
            }
        }
        return str.substring(start, start + longest);
    }
}
```



### 引子2：字符串查找

#### 方法一：暴力匹配

常规方法，时间复杂度为O(n^2)

```java
public class Solution {
    public static void main(String[] args) {
        int i = strStr("abcdbcdadd", "cda");
        System.out.println(i);
    }

    public static int strStr(String source, String target) {
        if (target == null || target.length() == 0){
            return 0;
        }

        for (int i = 0; i < source.length() - target.length() + 1; i++) {
            boolean notEqual = false;
            for (int j = 0; j < target.length(); j++) {
                if (source.charAt(i + j) != target.charAt(j)) {
                    notEqual = true;
                    break;
                }
            }
            if (!notEqual) {
                return i;
            }
        }
        return -1;
    }
}
```

#### 方法二：rabin-karp

#### 方法三：KMP





## 复杂度理论与双指针入门

### 四个复杂度

**时间复杂度 -> 核心考察点**

空间复杂度 - > 次要考察点

编程复杂度 - > 能看得懂

思维复杂度 - > 能想得出

### 时间复杂度

#### P问题

O(n), O(n^2), O(n^3)
O(n + m), O(√n), O(1)
O(logn), O(nlogn)

#### NP问题

O(2^n), O(n^n), O(n!)



O(n+m) 和 O(max(n,m)) 谁更大？ ->一样大

时间复杂度为O(N)的算法有哪些？

- **双指针算法**、打擂台算法（枚举法）、单调栈算法、单调队列算法

三种双指针算法：

- 相向双指针
  - reverse型
    - 翻转字符串
    - 判断回文串
  - two sum型
    - 两数之和
    - 三数之和
  - partition型（给一个数组，分成两部分，左边满足条件，右边不满足）
    - 快速排序
    - 颜色排序
- 背向双指针(最长回文串)
- 同向双指针

#### 例题1：相向双指针reverse型

判断一个字符串忽略大小写和非法字符之后是否是一个回文串

- race a car 不是回文
- A man, a plan, a canal: Panama 是回文

![image-20211124184843945](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211124184843945.png)



#### 例题2：相向双指针reverse型

判断一个而字符串是否可以在去掉一个字符的情况下是一个回文串

- abca 可以，去掉b或者c
- abc 无法做到

```java
public class Solution {

    public boolean validPalindrome(String str) {
        if (str == null) {
            return false;
        }
        Pair pair = different(str,0,str.length()-1);
        if (pair.left >= pair.right) {
            return true;
        }
        return isPalindrome(str, pair.left +1, pair.right) ||
                isPalindrome(str, pair.left, pair.right - 1);
        
    }
    
    public Pair different(String s, int left, int right) {
        while (left < right && s.charAt(left) == s.charAt(right)) {
            left++;
            right--;
        }
        return new Pair(left,right);
    }   
    
    public boolean isPalindrome(String s, int left, int right) {
        Pair pair = different(s, left, right);
        return pair.left >= pair.right;
    }
}

class Pair{
    int left, right;
    public Pair(int left, int right) {
        this.left = left;
        this.right = right;
    }
}
```



#### 例题3：two sum

##### 哈希表解法

```

```

##### 双指针解法

python版本：

```python
def twoSum(self, numbers, target):
    numbers.sort()
    left, right = 0, len(numbers) - 1
    while (left < right):
        if numbers[left] + number[right] > target:
            right--
        elif numbers[left] + numbers[right] < target:
            left++
        else:	
            return numbers[left], numbers[right]
    return [-1,-1]
```



## 快速排序与归并排序

### 快速排序

![image-20211124202827949](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211124202827949.png)

```java
public class Solution {
    public void sortInteger(int[] A) {
        quickSort(A, 0, A.length - 1);
    }
    public void quickSort(int[] arr, int start, int end) {
        int left = start, right = end;
        int pivot = arr[(left + right) / 2];
        while (left <= right) {
            while (left <= right && arr[left] < pivot) {
                left--;
            }
            while (left <= right && arr[right] > pivot) {
                right++;
            }
            if (left <= right) {
            	int temp = arr[left];
            	arr[left] = arr[right];
            	arr[right] = temp;
            	left++;
            	right--;
            }
        }
        quickSort(arr, start, right);
        quickSort(arr, left, end);
    }
}
```

### 归并排序

![image-20211124202706625](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211124202706625.png)

```java
public class MergeSort {

    public static void main(String[] args) {
        int[] arr = new int[]{8, 4, 5, 7, 1, 3, 6 ,2};
        sortInteger(arr);
    }
    public static void sortInteger(int[] arr) {
        if (arr == null || arr.length == 0){
            return;
        }
        int[] temp = new int[arr.length];
        mergeSort(arr, 0, arr.length - 1, temp);
        System.out.println(Arrays.toString(arr));
    }

    public static void mergeSort(int[] arr, int start, int end, int[] temp) {
        if (start >= end) {
            return;
        }
        mergeSort(arr, start, (end + start) / 2, temp);
        mergeSort(arr, (end + start) / 2 + 1, end, temp);
        merge(arr, start, end, temp);
    }
    public static void merge(int[] arr, int start, int end, int[] temp){
        int middle = (start + end) / 2;
        int leftIndex = start, rightIndex = middle + 1;
        int index = leftIndex;
        while (leftIndex <= middle && rightIndex <= end) {
            if (arr[leftIndex] <= arr[rightIndex]) {
                temp[index++] = arr[leftIndex++];
            }else {
                temp[index++] = arr[rightIndex++];
            }
        }
        while (leftIndex <= middle) {
            temp[index++] = arr[leftIndex++];
        }
        while (rightIndex <= end) {
            temp[index++] = arr[rightIndex++];
        }
        for (int i = start; i <= end; i++) {
            arr[i] = temp[i];
        }
    }
}
```

### 对比

快排先整体有序，后局部有序

归并先局部有序，再整体有序

快排不稳定，归并稳定

时间复杂度都是nlogn

空间复杂度，快排为O(1)，归并是O(n)



### 快速选择算法

快速选择算法用了快排的思想。例如找一个数组种第k大的数。快速选择算法的时间复杂度是O(n)

```java
    public static void main(String[] args) {
        int[] arr = new int[]{8, 4, 5, 7, 3, 6 ,2};
        System.out.println(quickSelect(arr,0, arr.length-1, 2));
    }
    public static int quickSelect(int[] arr, int start, int end, int k) {
        int pivot = arr[(start + end) / 2];
        int left = start, right = end, middle = (start + end) / 2;
        while (left <= right) {
            while (left <= right && arr[left] > pivot){
                left++;
            }
            while (right >= left && arr[right] < pivot) {
                right--;
            }
            if (left <= right) {
                int temp = arr[left];
                arr[left] = arr[right];
                arr[right] = temp;
                left++;
                right--;
            }
        }
        if ( start + k - 1 <= right) {
            return quickSelect(arr, start, right, k);
        }else if (start + k - 1 >= left) {
            return quickSelect(arr,left,end,k - (left - start));
        }
        else {
            return arr[right + 1];
        }
    }
```

## 递归三要素

- 递归的定义：函数接收什么样的参数，返回什么样的值，代表什么意思
- 递归的拆解：通过怎样的处理，让参数逐渐变小
- 递归的出口

## 二分法

[Binary Search · Binary Search - 九章算法 (jiuzhang.com)](https://www.jiuzhang.com/solutions/binary-search)

用二分法查找一个数**第一次出现的位置**、或者一个数**最后一次出现的位置**，或者一个数**第一次遇到大于等于它的位置**。

下面是一个非递归二分法的模板，可以在这个基础上简单修改即可完成多种类型的查找要求。

```java
    public static int position(int[] num, int target) {
        if (num == null || num.length == 0) {
            return -1;
        }
        int start = 0, end = num.length - 1;
        while (start + 1 < end) { // 避免在找lastPosition或firstPosition问题上出现死循环
            int mid = start + (end - start) / 2;
            if (num[mid] == target) {
                end = mid; // 如果是找最后一个值，遇到等于时，就要往右边找(start=mid)。如果是找第一次出现，遇到等于时，就往左边找(end=mid)
            }else if (num[mid] > target) {
                end = mid;
            }else {
                start = mid;
            }
        }

        if (num[start] == target) {
            return start;  // 找最后一个值的出口
        }
        if (num[end] == target) {
            return end;	// 找第一个值的出口
        }
        if (target < num[end] && target > num[start]) {
            return end;	// 应对找第一次遇到大于它的位置（数组种没有与他相等的情况）
        }
        return -1;
    }
```





