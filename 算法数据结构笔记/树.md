# 树结构基础

## 为什么用树结构

### 数组存储方式分析

数组存储

- 用下表方式访问元素，速度快。对于有序数组还可以用二分查找来提高检索速度
- 在插入和删除的时候，需要整体移动数组，效率低

- 有时候还要涉及数组扩容
- array list底层实现也用到了数组扩容

### 链表存储方式分析

插入删除快，检索慢

### 树存储方式分析

使用二叉树可以对数据的怎删改查效率都有所提高

## 二叉树的遍历

**前序遍历**: **先输出父节点**， 再遍历左子树和右子树

**中序遍历:** 先遍历左子树， **再输出父节点**， 再遍历右子树  

**后序遍历:** 先遍历左子树， 再遍历右子树， **最后输出父节点**

小结: 看输出父节点的顺序， 就确定是前序， 中序还是后序  

![image-20211105191038781](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105191038781.png)

```java
// 先定义节点类：包括节点属性和前中后序遍历方法
class HeroNode{
    // 定义节点基本属性
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;
    
    // 定义get，set方法
    ...
    
    // 定义遍历方法，核心就是看父节点输出的位置和递归情况
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }

    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

    public void postOrder(){
        if (this.left!=null){
            this.left.postOrder();
        }
        if (this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);
    }
}
// 定义一个二叉树类:包括根节点和前中后序遍历的方法
class BinaryTree{
    // 定义根节点
    private HeroNode root;
    public void setRoot(HeroNode root){
        this.root = root;
    }
    
    // 定义遍历方法
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    public void infixOrder(){
		...     // 将前序方法中的preOrder改成  infixOrder即可
    }
    public void postOrder(){
		...     // 将前序方法中的preOrder改成  postOrder即可
    }
    
}
// 应用：使用的时候先定义一堆节点，然后将节点组成一棵二叉树，直接对树调用相应的方法即可
public static void main(String[] args) {
    BinaryTree binaryTree = new BinaryTree();
        //创建需要的结点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");
//说明， 我们先手动创建该二叉树， 后面我们学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);
    
        System.out.println("前序遍历");//1,2,3,5,4
        binaryTree.preOrder();
}
```

## 二叉树的查找

![image-20211105193148794](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105193148794.png)

```java
// 扩展上面的节点类
class HeroNode{
    ...
    // 定义前中后序查找
    public HeroNode preOrderSearch(int no){
        if(this.no == no){
            return this;
        }
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }
    public HeroNode infixOrderSearch(int no){
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.no == no){
            return this;
        }
        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }
    // 后序查找同理
}
// 二叉树类中怎加查找方法
class BinaryTree{
    public HeroNode preOrderSearch(int no){
        if (this.root != null){
            return root.preOrderSearch(no);
        } else {
            return null;
        }
    }
}
```

## 二叉树删除节点

### 基础删除功能

待删除节点是叶子节点就直接删，不是叶子节点就直接删除子树

![image-20211105195722695](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105195722695.png)

```java
// 节点类中新增方法
class HeroNode{
    ...
    public void delNode(int no){
        if(this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        if(this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        if(this.left != null){
            this.left.delNode(no);
        }
        if(this.right != null){
            this.right.delNode(no);
        }
    }
}
// 二叉树类中新增方法
class BinaryTree{
    ...
    public void delNode(int no){
        if(root != null){
            if(root.getNo == no){
                root = null;
            }else{
                root.delNode(no);
            }
        }else{
            System.out.println("空树，不能删除啊");
        }
    }
}
```

### 进阶删除功能

如果删除的节点是非叶子节点，现在不希望删除该非叶子节点的子节点，此时就需要指定规则：

- 如果该非叶子节点 A 只有一个子节点 B， 则子节点 B 替代节点 A  
- 如果该非叶子节点 A 有左子节点 B 和右子节点 C， 则让左子节点 B 替代节点 A。  



## 顺序存储二叉树

基本说明：从数据存储来看， 数组存储方式和树的存储方式可以相互转换， 即数组可以转换成树， 树也可以转换成数组

要求：下面二叉树的结点， 要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 7]  

顺序存储二叉树的特点是：

* 顺序二叉树通常**只考虑完全二叉树**（可能不是满二叉树，但缺失只会发生在最后一行的最右边）
* **第 n 个元素的左子节点为 2 * n + 1**
* **第 n 个元素的右子节点为 2 * n + 2**
* **第 n 个元素的父节点为 (n-1) / 2**
* n : 表示二叉树中的第几个元素(**按 0 开始编号**如图所示)

<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105201852479.png" alt="image-20211105201852479" style="zoom:150%;" />

### 顺序存储二叉树的遍历

需求: 给你一个数组 {1,2,3,4,5,6,7}， 要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为
1,2,4,5,3,6,7  

```java
// 定义一个二叉树类
class ArrBinaryTree{
    // 既然是对数组遍历，那就先定义一个数组和其构造方法
    private int[] arr;
    public ArrBinaryTree(int[] arr){ this.arr = arr; }
    
    // 提供遍历方法的重载，使代码更简洁
    public void preOrder(){ this.preOrder(0) };
    
    // 定义前序遍历
    public void preOrder(int index){
        if(arr == null || arr.length == 0){
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        System.out.println(arr[index]);
        if((2*index+1)<arr.length){
            preOrder(2*index+1);
        }
        if((2*index+2)<arr.length){
            preOrder(2*index+2);
        }
    }
    // 中序和后序类似操作即可
}
```

**八大排序算法中的堆排序， 就会使用到顺序存储二叉树**



## 线索化二叉树

### 线索化二叉树的基本概念

一般情况下，对于一个完全二叉树，如果其有n个节点，那么就会有n+1（计算公式：2n-(n-1)）个空指针域。那么我们就可以考虑使用这些未被利用的左右指针，来存放某种遍历次序下的前驱节点和后继节点的指针。

> 一个节点的前一个节点，称为前驱节点。
>
> 一个节点的后一个节点，称为后继节点。
>
> 例如：对一个二叉树做中序遍历的结果是{8, 3, 10, 1, 14, 6} ，那么3的前驱节点是8，后继节点是10

![image-20211105205557721](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105205557721.png)

### 中序线索化二叉树

对上图的二叉树进行**中序线索二叉树**，中序遍历的数列为{8, 3, 10, 1, 14, 6}。

过程：对每个节点进行分析，如果这个节点的左右指针已被使用就跳过，未被使用就将其左指针指向前驱节点，右指针指向后继节点

![image-20211105205818165](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105205818165.png)

**说明**：当线索化二叉树后， Node 节点的 属性 left 和 right ， 有如下情况:  

- left 指向的是左子树， 也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.
-  right 指向的是右子树， 也可能是指向后继节点， 比如 ① 节点 right 指向的是右子树， 而⑩ 节点的 right 指向的是后继节点  

下面实现一个中序线索化二叉树：

```java
// 直接在前面写的节点类的基础上来写
class HeroNode{
    ... // 前面有写过的属性和方法
        
    // 现在每个节点的left和right属性可能是子树也可能是前驱后继节点，所以应该增加新的属性来区分
    // leftType== 0表示指向左子树，如果是1表示指向前驱节点
    private int leftType;
    private int rightType;
    // 再增加两个属性的get set方法
}

// 直接在前面写的二叉树上面修改成线索化二叉树的类
class ThreadBinaryTree{
    ... // 前面写过的属性和方法
        
    // 编写对二叉树进行中序线索化的方法
    // 因为是二叉树是单向的，线索化的时候需要前驱节点的信息，此时应该有一个指向当前节点的前一个节点的属性
    private HeroNode pre = null;
    public void threadedNodes(HeroNode node){
        // 先判断当前节点是否为空，是的话就返回
    	if(node == null){
            return;
        }
        
        // 1.先向左递归线索化
        threadedNode(node.getLeft());
        
        // 2.处理当前节点的线索化
        // 2.1处理前驱节点：如果当前节点左子节点为空，则将其左子节点设为前驱节点，将标签设置为1
        if(node.getLeft == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }
        // 2.2处理后继节点
        // 每个节点的后继节点，需要在本次递归结束后，返回上一层递归时执行。这是因为中序遍历是单向的，只能实现当前节点和遍历过的上一节点的操作，而获取不到下一个遍历的节点。
        if(pre != null && pre.getRight() == null){
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;
        
        // 3.向右递归线索化
        threadedNode(node.getRight());
    }
    
}
```

### 中序遍历线索化二叉树

对前面的中序线索化的二叉树， 进行遍历
分析： 因为线索化后， 各个结点指向有变化， 因此原来的遍历方式不能使用， 这时需要使用新的方式遍历
线索化二叉树， 各个节点可以通过线型方式遍历， 因此无需使用递归方式， 这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致 。

```java
// 在ThreadBinaryTree类中编写遍历方法
class ThreadBinaryTree{
    public void threadedList(){
        // 先取出当前的根节点
        HeroNode node = root;
        while(node != null){
            // 向左边循环直到找到第一个线索化节点
            while(node.getLeftType == 0){
                node = node.getLeft();
            }
            System.out.println(node);
            // 如果是线索化节点，就一直输出，直到遇到非线索化节点
            while(node.getRightType == 1){
                // 这里是先输出节点，再判断这个节点是否是线索化
                node = node.getRight();
                System.out.println(node);
            }
            // 遇到非线索化节点就继续往右边走
            node = node.getRight();
        }
    }
}
```

### 前序线索化二叉树及其遍历

```java
    // 对一棵二叉树做前序线索化
    public void threadedNodes(HeroNode node){

        if (node == null){return;}
        // 先处理当前节点的线索化
        if (node.getLeft() == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }
        if (pre != null && pre.getRight() == null ){
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;

        // 向左递归线索化
        if (node.getLeftType()==0){
            threadedNodes(node.getLeft());
        }
        // 向右递归线索化
        if (node.getRightType()==0){
            threadedNodes(node.getRight());
        }

    }

    // 做前序线索化遍历
    public void threadedList(){
        HeroNode node = root;
        while (node != null){
            System.out.println(node);
            //如果存在左子节点就往左走，否则往右走，此时右指针一定是前序遍历的下一个节点
            if (node.getLeftType() == 0){
                node = node.getLeft();
            }else{
                node = node.getRight();
            }
        }
    }
```

### 后序线索化及其遍历

后序线索化二叉树的遍历还不太明确，待定

```java
    public void postThreadedNodes(HeroNode node){
        if(node == null){return;}
        postThreadedNodes(node.getLeft());
        postThreadedNodes(node.getRight());
        if (node.getLeft() == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }
        if (pre != null && pre.getRight() == null){
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;
    }
    // 重载
    public void postThreadedList(){
        this.postThreadedList(root);
    }
    //遍历后续二叉树
    public void postThreadedList(HeroNode newRoot){
        if (newRoot.getLeftType()==0){
            postThreadedList(newRoot.getLeft());
        }
        if (newRoot.getRightType()==0){
            postThreadedList(newRoot.getRight());
        }
        System.out.println(newRoot);
    }
```

# 树结构的应用

# 十大常用算法

## 分治算法

