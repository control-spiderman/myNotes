# 一、树结构基础

## 为什么用树结构

### 数组存储方式分析

数组存储

- 用下表方式访问元素，速度快。对于有序数组还可以用二分查找来提高检索速度
- 在插入和删除的时候，需要整体移动数组，效率低

- 有时候还要涉及数组扩容
- array list底层实现也用到了数组扩容

### 链表存储方式分析

插入删除快，检索慢

### 树存储方式分析

使用二叉树可以对数据的怎删改查效率都有所提高

## 二叉树的遍历

**前序遍历**: **先输出父节点**， 再遍历左子树和右子树

**中序遍历:** 先遍历左子树， **再输出父节点**， 再遍历右子树  

**后序遍历:** 先遍历左子树， 再遍历右子树， **最后输出父节点**

小结: 看输出父节点的顺序， 就确定是前序， 中序还是后序  

![image-20211105191038781](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105191038781.png)

```java
// 先定义节点类：包括节点属性和前中后序遍历方法
class HeroNode{
    // 定义节点基本属性
    private int no;
    private String name;
    private HeroNode left;
    private HeroNode right;
    
    // 定义get，set方法
    ...
    
    // 定义遍历方法，核心就是看父节点输出的位置和递归情况
    public void preOrder(){
        System.out.println(this);
        if (this.left!=null){
            this.left.preOrder();
        }
        if (this.right!=null){
            this.right.preOrder();
        }
    }

    public void infixOrder(){
        if (this.left!=null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right!=null){
            this.right.infixOrder();
        }
    }

    public void postOrder(){
        if (this.left!=null){
            this.left.postOrder();
        }
        if (this.right!=null){
            this.right.postOrder();
        }
        System.out.println(this);
    }
}
// 定义一个二叉树类:包括根节点和前中后序遍历的方法
class BinaryTree{
    // 定义根节点
    private HeroNode root;
    public void setRoot(HeroNode root){
        this.root = root;
    }
    
    // 定义遍历方法
    public void preOrder(){
        if (this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树为空，无法遍历");
        }
    }
    public void infixOrder(){
		...     // 将前序方法中的preOrder改成  infixOrder即可
    }
    public void postOrder(){
		...     // 将前序方法中的preOrder改成  postOrder即可
    }
    
}
// 应用：使用的时候先定义一堆节点，然后将节点组成一棵二叉树，直接对树调用相应的方法即可
public static void main(String[] args) {
    BinaryTree binaryTree = new BinaryTree();
        //创建需要的结点
        HeroNode root = new HeroNode(1, "宋江");
        HeroNode node2 = new HeroNode(2, "吴用");
        HeroNode node3 = new HeroNode(3, "卢俊义");
        HeroNode node4 = new HeroNode(4, "林冲");
        HeroNode node5 = new HeroNode(5, "关胜");
//说明， 我们先手动创建该二叉树， 后面我们学习递归的方式创建二叉树
        root.setLeft(node2);
        root.setRight(node3);
        node3.setRight(node4);
        node3.setLeft(node5);
        binaryTree.setRoot(root);
    
        System.out.println("前序遍历");//1,2,3,5,4
        binaryTree.preOrder();
}
```

## 二叉树的查找

![image-20211105193148794](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105193148794.png)

```java
// 扩展上面的节点类
class HeroNode{
    ...
    // 定义前中后序查找
    public HeroNode preOrderSearch(int no){
        if(this.no == no){
            return this;
        }
        HeroNode resNode = null;
        if(this.left != null){
            resNode = this.left.preOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.right != null){
            resNode = this.right.preOrderSearch(no);
        }
        return resNode;
    }
    public HeroNode infixOrderSearch(int no){
        HeroNode resNode = null;
        if (this.left != null){
            resNode = this.left.infixOrderSearch(no);
        }
        if (resNode != null){
            return resNode;
        }
        if (this.no == no){
            return this;
        }
        if (this.right != null){
            resNode = this.right.infixOrderSearch(no);
        }
        return resNode;
    }
    // 后序查找同理
}
// 二叉树类中怎加查找方法
class BinaryTree{
    public HeroNode preOrderSearch(int no){
        if (this.root != null){
            return root.preOrderSearch(no);
        } else {
            return null;
        }
    }
}
```

## 二叉树删除节点

### 基础删除功能

待删除节点是叶子节点就直接删，不是叶子节点就直接删除子树

![image-20211105195722695](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105195722695.png)

```java
// 节点类中新增方法
class HeroNode{
    ...
    public void delNode(int no){
        if(this.left != null && this.left.no == no){
            this.left = null;
            return;
        }
        if(this.right != null && this.right.no == no){
            this.right = null;
            return;
        }
        if(this.left != null){
            this.left.delNode(no);
        }
        if(this.right != null){
            this.right.delNode(no);
        }
    }
}
// 二叉树类中新增方法
class BinaryTree{
    ...
    public void delNode(int no){
        if(root != null){
            if(root.getNo == no){
                root = null;
            }else{
                root.delNode(no);
            }
        }else{
            System.out.println("空树，不能删除啊");
        }
    }
}
```

### 进阶删除功能

如果删除的节点是非叶子节点，现在不希望删除该非叶子节点的子节点，此时就需要指定规则：

- 如果该非叶子节点 A 只有一个子节点 B， 则子节点 B 替代节点 A  
- 如果该非叶子节点 A 有左子节点 B 和右子节点 C， 则让左子节点 B 替代节点 A。  



## 顺序存储二叉树

基本说明：从数据存储来看， 数组存储方式和树的存储方式可以相互转换， 即数组可以转换成树， 树也可以转换成数组

要求：下面二叉树的结点， 要求以数组的方式来存放 arr : [1, 2, 3, 4, 5, 6, 7]  

顺序存储二叉树的特点是：

* 顺序二叉树通常**只考虑完全二叉树**（可能不是满二叉树，但缺失只会发生在最后一行的最右边）
* **第 n 个元素的左子节点为 2 * n + 1**
* **第 n 个元素的右子节点为 2 * n + 2**
* **第 n 个元素的父节点为 (n-1) / 2**
* n : 表示二叉树中的第几个元素(**按 0 开始编号**如图所示)

<img src="C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105201852479.png" alt="image-20211105201852479" style="zoom:150%;" />

### 顺序存储二叉树的遍历

需求: 给你一个数组 {1,2,3,4,5,6,7}， 要求以二叉树前序遍历的方式进行遍历。 前序遍历的结果应当为
1,2,4,5,3,6,7  

```java
// 定义一个二叉树类
class ArrBinaryTree{
    // 既然是对数组遍历，那就先定义一个数组和其构造方法
    private int[] arr;
    public ArrBinaryTree(int[] arr){ this.arr = arr; }
    
    // 提供遍历方法的重载，使代码更简洁
    public void preOrder(){ this.preOrder(0) };
    
    // 定义前序遍历
    public void preOrder(int index){
        if(arr == null || arr.length == 0){
            System.out.println("数组为空，不能按照二叉树的前序遍历");
        }
        System.out.println(arr[index]);
        if((2*index+1)<arr.length){
            preOrder(2*index+1);
        }
        if((2*index+2)<arr.length){
            preOrder(2*index+2);
        }
    }
    // 中序和后序类似操作即可
}
```

**八大排序算法中的堆排序， 就会使用到顺序存储二叉树**



## 线索化二叉树

### 线索化二叉树的基本概念

一般情况下，对于一个完全二叉树，如果其有n个节点，那么就会有n+1（计算公式：2n-(n-1)）个空指针域。那么我们就可以考虑使用这些未被利用的左右指针，来存放某种遍历次序下的前驱节点和后继节点的指针。

> 一个节点的前一个节点，称为前驱节点。
>
> 一个节点的后一个节点，称为后继节点。
>
> 例如：对一个二叉树做中序遍历的结果是{8, 3, 10, 1, 14, 6} ，那么3的前驱节点是8，后继节点是10

![image-20211105205557721](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105205557721.png)

### 中序线索化二叉树

对上图的二叉树进行**中序线索二叉树**，中序遍历的数列为{8, 3, 10, 1, 14, 6}。

过程：对每个节点进行分析，如果这个节点的左右指针已被使用就跳过，未被使用就将其左指针指向前驱节点，右指针指向后继节点

![image-20211105205818165](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20211105205818165.png)

**说明**：当线索化二叉树后， Node 节点的 属性 left 和 right ， 有如下情况:  

- left 指向的是左子树， 也可能是指向的前驱节点. 比如 ① 节点 left 指向的左子树, 而 ⑩ 节点的 left 指向的就是前驱节点.
-  right 指向的是右子树， 也可能是指向后继节点， 比如 ① 节点 right 指向的是右子树， 而⑩ 节点的 right 指向的是后继节点  

下面实现一个中序线索化二叉树：

```java
// 直接在前面写的节点类的基础上来写
class HeroNode{
    ... // 前面有写过的属性和方法
        
    // 现在每个节点的left和right属性可能是子树也可能是前驱后继节点，所以应该增加新的属性来区分
    // leftType== 0表示指向左子树，如果是1表示指向前驱节点
    private int leftType;
    private int rightType;
    // 再增加两个属性的get set方法
}

// 直接在前面写的二叉树上面修改成线索化二叉树的类
class ThreadBinaryTree{
    ... // 前面写过的属性和方法
        
    // 编写对二叉树进行中序线索化的方法
    // 因为是二叉树是单向的，线索化的时候需要前驱节点的信息，此时应该有一个指向当前节点的前一个节点的属性
    private HeroNode pre = null;
    public void threadedNodes(HeroNode node){
        // 先判断当前节点是否为空，是的话就返回
    	if(node == null){
            return;
        }
        
        // 1.先向左递归线索化
        threadedNode(node.getLeft());
        
        // 2.处理当前节点的线索化
        // 2.1处理前驱节点：如果当前节点左子节点为空，则将其左子节点设为前驱节点，将标签设置为1
        if(node.getLeft == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }
        // 2.2处理后继节点
        // 每个节点的后继节点，需要在本次递归结束后，返回上一层递归时执行。这是因为中序遍历是单向的，只能实现当前节点和遍历过的上一节点的操作，而获取不到下一个遍历的节点。
        if(pre != null && pre.getRight() == null){
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;
        
        // 3.向右递归线索化
        threadedNode(node.getRight());
    }
    
}
```

### 中序遍历线索化二叉树

对前面的中序线索化的二叉树， 进行遍历
分析： 因为线索化后， 各个结点指向有变化， 因此原来的遍历方式不能使用， 这时需要使用新的方式遍历
线索化二叉树， 各个节点可以通过线型方式遍历， 因此无需使用递归方式， 这样也提高了遍历的效率。 遍历的次序应当和中序遍历保持一致 。

```java
// 在ThreadBinaryTree类中编写遍历方法
class ThreadBinaryTree{
    public void threadedList(){
        // 先取出当前的根节点
        HeroNode node = root;
        while(node != null){
            // 向左边循环直到找到第一个线索化节点
            while(node.getLeftType == 0){
                node = node.getLeft();
            }
            System.out.println(node);
            // 如果是线索化节点，就一直输出，直到遇到非线索化节点
            while(node.getRightType == 1){
                // 这里是先输出节点，再判断这个节点是否是线索化
                node = node.getRight();
                System.out.println(node);
            }
            // 遇到非线索化节点就继续往右边走
            node = node.getRight();
        }
    }
}
```

### 前序线索化二叉树及其遍历

```java
    // 对一棵二叉树做前序线索化
    public void threadedNodes(HeroNode node){

        if (node == null){return;}
        // 先处理当前节点的线索化
        if (node.getLeft() == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }
        if (pre != null && pre.getRight() == null ){
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;

        // 向左递归线索化
        if (node.getLeftType()==0){
            threadedNodes(node.getLeft());
        }
        // 向右递归线索化
        if (node.getRightType()==0){
            threadedNodes(node.getRight());
        }

    }

    // 做前序线索化遍历
    public void threadedList(){
        HeroNode node = root;
        while (node != null){
            System.out.println(node);
            //如果存在左子节点就往左走，否则往右走，此时右指针一定是前序遍历的下一个节点
            if (node.getLeftType() == 0){
                node = node.getLeft();
            }else{
                node = node.getRight();
            }
        }
    }
```

### 后序线索化及其遍历

后序线索化二叉树的遍历还不太明确，待定

```java
    public void postThreadedNodes(HeroNode node){
        if(node == null){return;}
        postThreadedNodes(node.getLeft());
        postThreadedNodes(node.getRight());
        if (node.getLeft() == null){
            node.setLeft(pre);
            node.setLeftType(1);
        }
        if (pre != null && pre.getRight() == null){
            pre.setRight(node);
            pre.setRightType(1);
        }
        pre = node;
    }
    // 重载
    public void postThreadedList(){
        this.postThreadedList(root);
    }
    //遍历后续二叉树
    public void postThreadedList(HeroNode newRoot){
        if (newRoot.getLeftType()==0){
            postThreadedList(newRoot.getLeft());
        }
        if (newRoot.getRightType()==0){
            postThreadedList(newRoot.getRight());
        }
        System.out.println(newRoot);
    }
```

# 二、树结构的应用

## 1. 堆排序

### 01 什么是堆？

堆是具有以下性质的**完全二叉树**：每个结点的值都大于或等于其左右孩子结点的值，称为**大顶堆**,。每个结点的值都小于或等于其左右孩子结点的值，称为**小顶堆**。

> 注意: 没有要求结点的左孩子的值和右孩子的值的大小关系。

### 02 堆排序基本思想

- 将待排序序列构造成一个大顶堆
- 此时，整个序列的最大值就是堆顶的根节点。
- 将其与末尾元素进行交换，此时末尾就为最大值。
- 然后将剩余n-1 个元素重新构造成一个堆，这样会得到n 个元素的次小值。如此反复执行，便能得到一个有序
  序列了。

> 从始至终都是在数组上操作的，只不过是按照树的结构遍历

### 03 堆排序步骤

1.给定一个原始无序数组，将其想象成完全二叉树顺序存储的结构，那么它满足条件：

* **第 n 个元素的左子节点为 2 * n + 1**
* **第 n 个元素的右子节点为 2 * n + 2**
* **第 n 个元素的父节点为 (n-1) / 2**

> 注意：n是从零开始的

<img src="C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211114151658729.png" alt="image-20211114151658729" style="zoom: 80%;" />

2.然后找到**最后一个非叶子节点（它是最后一个元素的父节点**），即序号为 ((arr.length-1)-1) / 2的节点。将该节点与其两个子节点比较，小于就交换，大于就不变。

<img src="C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211114151721028.png" alt="image-20211114151721028" style="zoom:80%;" />

3.找**下一个非叶子节点（它应该最后一个节点位置减去2的节点对应的父节点）**，继续执行上面的比较和交换

<img src="C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211114151747005.png" alt="image-20211114151747005" style="zoom:80%;" />

4.直到最后一个非叶子节点即为根节点时结束，此时构造成一个大顶堆。将堆顶元素（数组第一个位置）与数组的最后一个元素交换位置。重新调整堆的结构：构造一个不包含数组最后元素的堆。重复这个过程，直到堆结构只有1个元素，此时已经满足升序排序。

### 04 堆排序代码实现

注意点：第一次堆顶元素下沉后，之后的就只用调整堆顶元素为大顶堆了，而不用从最后一个非叶子节点处开始。

```java
import java.util.Arrays;


public class HeapSort {
    public static void main(String[] args) {
        int arr[] = {4, 6, 8, 5, 9,11,2,7,5,1,3};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    public static void heapSort(int arr[]){
        // 下面这个方法是我自己写的，这个方法在第二层循环时，每次都从最后一个非叶子节点调整，但实际上，在第一次的时候就已经
        // 调整好了堆的中间部分，只有堆顶元素待调整。因此做了很多无用功，第二次之后就只用调整堆顶元素了。

//        // 第一层循环是为了每次将堆顶元素下沉，循环arr.length-1次
//        for(int length = arr.length; length>0; length--){
//            // 第二层循环是对当前的堆，从最后一个非叶子节点循环到堆顶来做堆调整
//            for (int i = length/2 - 1; i>=0 ; i--){
//                adjustHeap(arr,i,length);
//            }
//            int temp = arr[length-1];
//            arr[length-1] = arr[0];
//            arr[0] = temp;
//        }

        // 新方法
        for (int i= arr.length/2; i>=0; i--){
            adjustHeap(arr,i, arr.length);
        }
        int temp = 0;
        for (int j = arr.length-1; j>0; j--){
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr,0,j);
        }
    }

    /**
     * 该方法将以i节点为父节点的子树，调整成大顶堆结构。
     * 因为规则是从最后一个非叶子节点开始的。所以保证了i节点的子树：除了i节点部分，其他子部分都是大顶堆的；
     * 所以该函数就只是将i节点放在其子树中合适的位置
     * @param arr
     * @param i
     * @param length
     */
    public static void adjustHeap(int arr[],int i,int length){
        int temp = arr[i];
        for (int k = i*2+1; k < length; k = 2*k+1){
            if (k+1<length && arr[k] < arr[k+1]){
                k++;
            }
            if (arr[k] > temp){
                arr[i] = arr[k];
                i = k;
            }else{
                break;
            }
        }
        arr[i] = temp;
    }
}
```



## 2. 霍夫曼树

### 01 基本介绍

**赫夫曼树就是带权路径长度（WPL）之和最小的树结构。**带权指的是一棵树的每个叶子节点都有一个权值，路径指的是从根节点到这个叶子节点之间的边的条数。从根节点到某一个叶子节点的带权路径长度就是边的条数乘以该叶子节点的权值。

举个图例：

<img src="C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211114165347380.png" alt="image-20211114165347380"  />

中间这棵树就是一棵赫夫曼树

### 02 赫夫曼树构建思路

- 给定一个数组，将其从小到大排序
- 取出数组中最小的两个元素作为左右子节点构成一个二叉树，该二叉树的根节点的权值即为两个元素的和，然后用根节点值替换数组中取出的两个最小值，构成新的数组。
- 从新数组中取出最小的两个数，重复第二步，直到新数组中元素个数为1，此时就构建了一棵赫夫曼树。

例如：

将数组{13, 7, 8, 3, 29, 6, 1}构建成一棵赫夫曼数：

<img src="C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211114165847674.png" alt="image-20211114165847674"  />

### 03 赫夫曼树代码实现

思路：

要先定义节点结构：value、left、right。并且节点**要实现comparabel接口，定义重写比较方法**

然后写赫夫曼树创建函数：

- 先定义一个元素是节点的arrayList，然后将数组所有元素作为节点的value存到arraylist中。
- 写一个循环，从arraylist的size遍历到1。每次遍历中都先将arraylist排好序，然后取出前两个节点作为左右子节点，new一个他们的parent节点。删除arraylist中的前两个节点并新增一个parent节点。

```java
package treeApplcation;

import java.util.ArrayList;
import java.util.Collections;

public class HuffmanTree {

    public static void main(String[] args) {
        int arr[] = {13, 7, 8, 3, 29, 6, 1};
        createHuffmanTree(arr);
    }
    public static void createHuffmanTree(int arr[]){
        ArrayList<Node> nodes = new ArrayList<>();
        for (int i=0; i<arr.length;i++){
            nodes.add(new Node(arr[i]));
        }
        for (int j=nodes.size();j>1;j--){
            Collections.sort(nodes);
            Node leftNode = nodes.get(0);
            Node rightNode = nodes.get(1);
            Node parent = new Node(nodes.get(0).value+nodes.get(1).value);
            parent.setLeft(leftNode);
            parent.setRight(rightNode);
            nodes.remove(leftNode);
            nodes.remove(rightNode);
            nodes.add(parent);
        }
        System.out.println(nodes);

    }
}

class Node implements Comparable<Node>{
    int value;
    Node left;
    Node right;
    public void setLeft(Node left) {
        this.left = left;
    }
    public void setRight(Node right) {
        this.right = right;
    }
    public Node(int value) {
        this.value = value;
    }
    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                ", left=" + left +
                ", right=" + right +
                '}';
    }
    @Override
    public int compareTo(Node o) {
        return this.value - o.value;
    }
}
```

#### java技术点

comparable接口



## 3. 霍夫曼编码

### 01 数据压缩

通信领域的数据压缩，常规的处理方法就是：统计数据中相同字符的个数，然后对每个字符都指定一个对应的二进制数字，用二进制数字组成原来的数据。

<img src="C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211114175234535.png" alt="image-20211114175234535"  />

但这种方法有个问题就是，有些字符对应的二进制数字串会使另一些字符的前缀二进制数字串，例如上面a就是i的前缀。这样在解码的时候，就会产生二义性。

### 02 赫夫曼编码原理

针对上面的二义性问题，提出了赫夫曼编码。

赫夫曼编码的步骤：

1)传输的字符串：i like like like java do you like a java

2) 字符统计：d:1 y:1 u:1 j:2 v:2 o:2 l:4 k:4 e:4 i:5 a:5  :9

3) 按照上面字符出现的次数构建一颗赫夫曼树, **次数作为权值**

![image-20211114175820541](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211114175820541.png)

4) 根据赫夫曼树，给各个字符规定编码(前缀编码)， **向左的路径为0 向右的路径为1** ， 编码如下:
o: 1000 	u: 10010 	d: 100110 	y: 100111 	i: 101
a : 110 	k: 1110 	e: 1111 	j: 0000 	v: 0001
l: 001 	 : 01

> **因为每个字符都在赫夫曼树的叶子节点上，上面这种编码规则可以保证每个字符的二进制编码都是独一无二的，不会产生二义性**

5) 按照上面的赫夫曼编码，我们的"i like like like java do you like a java" 字符串对应的编码为(注意这里我们使用的无损压缩)
10101001101111011110100110111101111010011011110111101000011000011100110011110000110
01111000100100100110111101111011100100001100001110 通过赫夫曼编码处理长度为133

> **赫夫曼编码是无损处理方案**

**注意事项**

根据赫夫曼树排序方法的不同，构造的赫夫曼树可能不同，对应的赫夫曼编码就可能不同。但是无论排序方法怎样，只要保证了wpl一样，就可以保证最后生成的赫夫曼编码的长度是一样的。

### 03 创建赫夫曼树：以数据压缩为案例

这一部分重点就是getNodeList这个方法，将一个字符串生成成一个ArrayList<Node>。其他部分都是前面的内容

```java
package treeApplcation;

import java.nio.charset.StandardCharsets;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;

public class HuffmanCode {
    public static void main(String[] args) {
        String content = "i like like like java do you like a java";
        byte[] contents = content.getBytes();
        ArrayList<NodeData> nodeList = getNodeList(contents);
        NodeData huffmanTree = createHuffmanTree(nodeList);
        preOrder(huffmanTree);
    }

    // 一个前序遍历方法，用来看看赫夫曼树是否构建成功
    private static void preOrder(NodeData nodeData){
        if (nodeData != null){
            nodeData.preOrder();
        }else{
            System.out.println("赫夫曼树为空");
        }
    }

    // 将字符串的byte数组转换成char和weight，并返回一个node组成的arraylist
    public static ArrayList<NodeData> getNodeList(byte[] con){
        Map<Byte,Integer> map = new HashMap<>();
        for (byte b: con){
            map.merge(b, 1, Integer::sum);
        }
//          上面这个for循环的一个笨办法：
//        for (byte b: con){
//            Integer data = map.get(b);
//            if (data == null){
//                map.put(b,1);
//            }else{
//                map.put(b,data+1);
//            }
//        }

        ArrayList<NodeData> nodeData = new ArrayList<>();
        for (Map.Entry<Byte,Integer> entry: map.entrySet()){
            nodeData.add(new NodeData(entry.getKey(),entry.getValue()));
        }
        return nodeData;
    }

    // 构造赫夫曼树,前面一样的方法
    private static NodeData createHuffmanTree(ArrayList<NodeData> nodeData){
        while (nodeData.size()>1){
			... // 前面一样的
        }
        return nodeData.get(0);
    }
}


class NodeData implements Comparable<NodeData>{
    Byte data;
    int weight;
    NodeData left;
    NodeData right;

    public NodeData(Byte data, int weight) {
        this.data = data;
        this.weight = weight;
    }
    @Override
    public String toString() {
		...
    }
    @Override
    public int compareTo(NodeData o) {
        return this.weight - o.weight;
    }
    public void preOrder(){
        System.out.println(this);
        if (this.left != null){
            this.left.preOrder();
        }
        if (this.right != null){
            this.right.preOrder();
        }
    }
}
```

### 04 生成赫夫曼编码表

直接在主类中添加下面的方法和属性：

```java
    // 根据生成的赫夫曼树生成相对应的赫夫曼编码，这个编码结果用一个map<byte,String>来存储
    static Map<Byte,String> huffmanMap = new HashMap<>();
    // 还需要定义一个StringBuilder来存储累加的编码
    static StringBuilder stringBuilder = new StringBuilder();

    // 写个getHuffmanCode的重载方法
    private static Map<Byte,String> getHuffmanCode(NodeData nodeData){
        if (nodeData == null){
            return null;
        }
        getHuffmanCode(nodeData.left,"0",stringBuilder);
        getHuffmanCode(nodeData.right,"1",stringBuilder);
        return huffmanMap;
    }

    /**
     *
     * @param nodeData
     * @param code 向左遍历就是0，向右遍历就是1
     * @param stringBuilder
     */
    public static void getHuffmanCode(NodeData nodeData,String code,StringBuilder stringBuilder){
        StringBuilder stringBuilder1 = new StringBuilder(stringBuilder);
        stringBuilder1.append(code);
        if (nodeData != null){
            if (nodeData.data == null){
                getHuffmanCode(nodeData.left,"0",stringBuilder1);
                getHuffmanCode(nodeData.right,"1",stringBuilder1);
            }else{
                huffmanMap.put(nodeData.data, stringBuilder1.toString());
            }
        }
    }
```

##### java技术点

stringBuilder

static关键字

### 05 生成赫夫曼编码字节数组

直接在主类中添加下面的方法和属性。该方法主要点是数据不同进制之间的转换

```java
    /**
     * 传入一个字符串和赫夫曼编码表，将字符串转成赫夫曼编码字节数组
     * @param content
     * @return
     */
    public static byte[] zip(String content, Map<Byte,String> huffmanMap){
        // 先将数据转换成二进制字节数组
        StringBuilder biCode = new StringBuilder();
        for (byte bt: content.getBytes()){
            biCode.append(huffmanMap.get(bt));
        }
        // 根据二进制字节数组的长度计算最终字节数组所需要的大小
        int len = (biCode.length()+7) / 8;
        // 定义一个接收最终结果的byte数组
        byte[] zipData = new byte[len];
        // 在将二进制字符串转换成二进制字节
        int index = 0;
        String substring;
        for(int i=0; i<biCode.length();i+=8){
            if (i+8>biCode.length()){ //不够8位的情况
                substring = biCode.substring(i);
            }else{
                substring = biCode.substring(i, i + 8);
            }
            zipData[index] =(byte) Integer.parseInt(substring,2);
            index++;
        }
        return zipData;
    }
```

##### java技术点

java中不同进制之间的转换

### 06 赫夫曼解码

目的：将[-88,100....]转换成i like like like java do you like a java"

步骤：

- 先将[-88,100....]转换成10101000100....这样的bit字符串
- 再将赫夫编码表的key和value交换，因为要做反向查询操作
- 最后循环取出bit字符串中的每个字符组成一个新的子字符串，如果该子字符串是赫夫曼编码表的key，就取出value，存到一个arraylist中。遍历结束，将arraylist中的结果存到一个byte数组中，最后用这个byte数组构造出目标字符串。

```java
    // 数据解压
    // 先将字节数组转换成二进制字符串。即-88 ->10110100
    // 再将二进制字符串根据编码表转换成原来的数据
    private static String decode(Map<Byte,String> huffmanCode, byte[] huffmanBytes){
        //
        StringBuilder stringBuilder = new StringBuilder();
        for (int i=0; i<huffmanBytes.length; i++){
            boolean flag = i == huffmanBytes.length-1;
            stringBuilder.append(byteToBitString(!flag,huffmanBytes[i]));
        }
        // 将编码表的key和value调换
        Map<String,Byte> huffmanDecodeMap = new HashMap<>();
        for (Map.Entry<Byte,String> entry:huffmanCode.entrySet()){
            huffmanDecodeMap.put(entry.getValue(),entry.getKey());
        }
        ArrayList<Byte> list = new ArrayList<>();   // 用来存不定数量的字节
        for (int i=0 ;i < stringBuilder.length();){
            boolean flag = true;
            int count = 0;

            while(flag){
                String key = stringBuilder.substring(i,i+count)
                Byte aByte = huffmanDecodeMap.get(key);
                if (aByte != null){
                    list.add(aByte);
                    flag = false;
                }else{
                    count++;
                }
            }
            i += count;
        }
        byte[] b = new byte[list.size()];
        // 还需要将不定长度的字节数组转换成byte数组
        for (int i =0; i<list.size();i++){
            b[i] = list.get(i);
        }
        String answer = new String(b);
        return answer;
    };

    /**
     * 这个函数用于把byte转成bit string。如果是字节数组的最后一个则不需要补高位，其他的都需要补高位
     * @param flag  这个参数就是确定，当前字符串是否需要补高位
     * @param bt
     * @return
     */
    private static String byteToBitString(boolean flag,byte bt){
        int temp = bt;
        if (flag){
            temp |= 256; // 这个方法就是补高位操作，将bt与256（1 0000 0000）按位或操作
        }
        String string = Integer.toBinaryString(temp);
        String str = "";
        if (flag){
            return string.substring(string.length()-8);
        }else{
            return string;
        }
    }
```



### 07 文件压缩

文件压缩主要就是涉及到java中的io操作。这里是构建了一个对象输出流ObjectOutputStream。用这个存数据才能保证到时候分别读出编码表和编码数据。

```java
       public static void main(String[] args) {
        String srcFile = "D://test.txt";
        String dstFile = "D://zipFile1.zip";
        zipFile(srcFile,dstFile);
        System.out.println("已经压缩。。。");
    }

	// 文件压缩
    private static void zipFile(String srcFile,String dstFile){
        FileInputStream is = null;
        OutputStream os = null;
        ObjectOutputStream oos = null;
        try {
            is = new FileInputStream(srcFile);
            byte[] data = new byte[is.available()];
            is.read(data);
            byte[] huffmanCodeBytes = huffmanCodeBytes(data);
            os = new FileOutputStream(dstFile);
            oos = new ObjectOutputStream(os);
            oos.writeObject(huffmanCodeBytes);
            oos.writeObject(huffmanMap);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            try{
                oos.close();
                os.close();
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

### 08 文件解压

和文件压缩差不多，就是要构建一个对象输入流ObjectInputStream来分别读取赫夫曼编码表和赫夫曼编码数据

```java
// 文件解压
    private static void unZipFile(String srcFile,String dstFile) {
        FileInputStream is = null;
        ObjectInputStream ois = null;
        OutputStream os = null;
        try {
            is = new FileInputStream(srcFile);
            ois = new ObjectInputStream(is);
            byte[] huffmanEncodeData =(byte[]) ois.readObject();
            Map<Byte,String> huffmanCode =(Map<Byte,String>) ois.readObject();
            byte[] decode = decode(huffmanCode, huffmanEncodeData);
            os = new FileOutputStream(dstFile);
            os.write(decode);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }finally {
            try {
                os.close();
                ois.close();
                is.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }
```

### 09 总结

##### 数制间的转换：

```java
// 1. 将字节码数组转换成对应的字符串  
byte[] bts = [105,35...];
// 注意！！！！ 千万不要用Arrays.toSting(bts)这样就是直接将原来的字节码转换成字符串，而没有了字节码信息
String str = new String(bts);	//"i like like like java do...."

// 2. str.getBytes()将字符串转为对应的字节码数组
String content = "i like like like java do you like a java"; // 40个字符
byte[] contents = content.getBytes();	// content=[105,35...] 共40个二进制byte

String subString = "10101000";
//Integer.parseInt(substring,2) 将一个字符串按照指定的基数转换成相应的进制byte
byte bt = (byte) Integer.parseInt(substring,2);	//-88

byte bt = -88;
int temp = bt;	//-88
String string = Integer.toBinaryString(temp);//32位补码：11111111111111111111111110101000
```

##### 亮点技巧：

```java
// 1.hashMap中的元素遍历方法
for (Map.Entry<Byte,String> entry:huffmanCode.entrySet()){
            huffmanDecodeMap.put(entry.getValue(),entry.getKey());
        }
// 2.对整数的二进制表示做高位填补的方法：按位或
int temp = -88
temp |= 256; // 这个方法就是补高位操作，将bt与256（1 0000 0000）按位或操作

// 3.map中value查询与赋值的简单操作，java8新增方法
for (byte b: con){
            map.merge(b, 1, Integer::sum);//map中key为b的value为空则赋1，不为空则将结果和1求sum
        }
//

// 4.根据二进制字节数组的长度计算最终字节数组所需要的大小：利用除法向下取整的特性
        int len = (biCode.length()+7) / 8;
```

> **java中的map.merge()方法：**
>
> merge方法有三个参数，key：map中的键，value：使用者传入的值，remappingFunction：BiFunction函数接口(该接口接收两个值，执行自定义功能并返回最终值)。当map中不存在指定的key时，便将传入的value设置为key的值，当key存在值时，执行一个方法：该方法**接收key的旧值和传入的value**，执行自定义的方法返回最终结果设置为key的值。



### 10 注意！！

**对于文件的io操作或者其他数据读取写入操作（包括函数参数和返回值），都要以字节数组的形式来操作，尽量不要转换成字符串的形式。只有在显示、需要看的时候再转换。**

> 全部的代码在HuffmanCode.java这个文件中。

1) 如果文件本身就是经过压缩处理的，那么使用赫夫曼编码再压缩效率不会有明显变化, 比如视频,ppt 等等文件 [举例压一个 .ppt] 

2) 赫夫曼编码是按字节来处理的，因此可以处理所有的文件(二进制文件、文本文件) [举例压一个.xml 文件] 

3) 如果一个文件中的内容，重复的数据不多，压缩效果也不会很明显.



## 4. 二叉排序树

### 01 二叉排序树介绍

二叉排序树：BST: (Binary Sort(Search) Tree), 对于二叉排序树的任何一个非叶子节点，要求左子节点的值比当前节点的值小，右子节点的值比当前节点的值大。

比如针对前面的数据(7, 3, 10, 12, 5, 1, 9) ，对应的二叉排序树为：

![image-20211116175435331](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211116175435331.png)

当采用中序遍历的时候，遍历的结果就是一个排好序的数组。

### 02 二叉排序树的创建和遍历

比较简单，用的中序遍历。

```java
package treeApplcation;

// 二叉排序树的创建和遍历
public class BinarySortTree {
    public static void main(String[] args) {
        int arr[] = {7, 3, 10, 12, 5, 1, 9};
        BinarySortTreeDemo treeDemo = new BinarySortTreeDemo();
        for (int i=0; i < arr.length; i++){
            treeDemo.add(new bstNode(arr[i]));
        }
        treeDemo.infixOrder();
    }
}
class BinarySortTreeDemo{
    bstNode root;

    public void add(bstNode node){
        if (this.root == null){
            root = node;
        }else{
            root.add(node);
        }
    }
    public void infixOrder(){
        if (this.root == null){
            System.out.println("空树");
        }else{
            root.infixOrder();
        }
    }
}
class bstNode{
    int value;
    bstNode left;
    bstNode right;
    public bstNode(int value) {
        this.value = value;
    }
    @Override
    public String toString() {
        return "bstNode{" +
                "value=" + value +
                '}';
    }
    public void add(bstNode node){
        if (node == null){
            return;
        }
        if (node.value < this.value){
            if (this.left == null){
                this.left = node;
            }else{
                this.left.add(node);
            }
        }else{
            if (this.right == null){
                this.right = node;
            }else{
                this.right.add(node);
            }
        }
    }
    public void infixOrder(){
        if (this.left != null){
            this.left.infixOrder();
        }
        System.out.println(this);
        if (this.right != null){
            this.right.infixOrder();
        }
    }
}
```

### 03 二叉排序树的删除

1.删除一个节点需要先找到该节点，并且还需要找到该节点的父节点，这样才能执行删除操作。因此在node类中需要先定义节点的查找方法和父节点查找方法。

2.节点的删除需要处理三种情况：目标节点是叶子节点、目标节点有一个子节点、目标节点有两个节点。

第一种情况：直接判定该节点是父节点的左子还是右子节点，然后直接幅值为null。

第二种情况：判定目标节点的子节点是左子还是右子，用一个中间变量来存储这个子节点，再将这个子节点从目标节点上删除。然后再判断目标节点是父节点的左子还是右子，直接将父节点相应的子节点赋值为中间变量。

第三种情况：现在node类中定义一个寻找最小值节点的方法，然后在删除方法中，用目标节点的右子节点调用这个findmin方法，取到最小值存到一个中间变量；再递归调用该删除方法，删除这个最小节点；最后将目标节点的value设置为和中间变量。

```java
// 在binarysearch类中添加以下几个方法
class BinarySortTreeDemo{
    public bstNode search(int value){
        if (root == null){
            return null;
        }else{
            return root.search(value);
        }
    }
    public bstNode searchParent(int value){
        if (root == null){
            return null;
        }else{
            return root.searchParent(value);
        }
    }
    public void delNode(int value){
        if (root ==null){
            return;
        }else{
            bstNode targetNode = search(value);
            if (targetNode == null){
                return;
            }
            if (root.right == null && root.left == null){   //如果只有一个根节点，那这个根节点就是目标节点
                root = null;
                return;
            }
            bstNode parentNode = searchParent(value);
            if (targetNode.left == null && targetNode.right == null &&parentNode!=null){
                // 目标节点是个叶子节点的情况
                if (targetNode == parentNode.left){
                    parentNode.left = null;
                }else{
                    parentNode.right = null;
                }
            }else if(targetNode.left != null && targetNode.right == null){
                bstNode temp = targetNode.left;
                targetNode.left = null;
                // 目标节点只有一个左子节点
                if (parentNode == null){
                    root = temp;
                }else if(parentNode.left == targetNode){
                    parentNode.left = temp;
                }else{
                    parentNode.right = temp;
                }
            }else if (targetNode.right != null && targetNode.left == null){
                bstNode temp = targetNode.right;
                targetNode.right = null;
                // 目标节点只有一个右子节点
                if (parentNode == null){
                    root = temp;
                } else if (parentNode.left == targetNode){
                    parentNode.left = temp;

                }else{
                    parentNode.right = temp;
                }
            }else {
                // 目标节点有两个节点
                int minValue = targetNode.right.findMin().value;
                delNode(targetNode.right.findMin().value);
                targetNode.value = minValue;
            }
        }
    }
}

// 在node类中添加以下几个方法
class bstNode{
    public bstNode search(int value){
        if (this.value == value){
            return this;
        }else if (this.value > value && this.left != null){
            return this.left.search(value);
        }else if (this.value < value && this.right != null){
            return this.right.search(value);
        }else{
            return null;
        }
    }

    public bstNode searchParent(int value){
        if ((this.left!=null && this.left.value == value) ||
                (this.right!=null && this.right.value == value)){
            return this;
        }else{
            if (this.left != null && this.value > value){
                return this.left.searchParent(value);
            }else if (this.right != null && this.value < value){
                return this.right.searchParent(value);
            }else{
                return null;
            }
        }
    }

    public bstNode findMin(){
        if (this.left != null){
            return this.left.findMin();
        }
        return this;
    }
}
```

#### 递归中易错点

**1.递归时注意一定要有返回值**

**2.用到if else if时，注意递归的并行性，不要进入到错误的递归中查找。**

```java
// 1.寻找最小值的点，最开始写成这样：
public bstNode findMin(){
    if (this.left != null){
        this.left.findMin();
    }
    return this;
}
// 这样写的话，无论递归了多少层，都没用到每层递归返回的值，所以在写递归的时候一定要注意，要给递归处写一个接收值的变量，或者return。
// 此外上面这个方法，永远都只会返回最外一层的this。


// 2.在寻找父节点的值的时候，我最开始写成这样：
public bstNode searchParent(int value){
    if ((this.left!=null && this.left.value == value) ||
        (this.right!=null && this.right.value == value)){
        return this;
    }else{
        if (this.left != null){
            return this.left.searchParent(value);
        }else if (this.right != null){
            return this.right.searchParent(value);
        }else{
            return null;
        }
    }
}
// 在第二个if中，由于没有写出全部的判断语句（&& this.left.value == value），这样导致：如果目标节点在this节点的右子树中，那么第一个if进到左子树的递归，这样其里面的递归全都不会有返回值；直到最外一层递归时，任然返回null，而因为if和else if是并行的，所以永远不会进到第二个else if中，这样就直接返回null了。
// 我要说明的是，在写递归的时候要注意递归的并行性。一开始就要注意不要进入到错误的递归中。
```

#### 树的节点删除操作注意点：

java中当一个元素没有被任何应用时，就会被垃圾回收机制回收。而一棵树中只定义了一个根节点，当非根节点没有被任何参数引用（如根节点的root和targetNode、parentNode等）或间接引用（如节点的子节点）时就会被删除。





## 5. 平衡二叉树（AVL）

### 01 问题介绍

对于数列{1,2,3,4,5,6}这种类型的，要求创建一个二叉排序树。发现其创建的二叉排序树左子树全为空，看上去更像一个单链表。这样插入速度没有影响，但查询速度明显降低（因为还需要以此比较，判断左边是否非空），不能发挥BST的优势，其查询速度比 单链表还慢。

针对上面提出的问题，解决方案：平衡二叉树。



### 02 AVL树介绍

1）平衡二叉树也叫平衡二叉搜索树（Self-balancing binary search tree）又被称为AVL 树， 可以保证查询效率高。

2) 具有以下特点：它是**一棵空树**或**它的左右两个子树的高度差的绝对值不超过1**，**并且左右两个子树都是一棵**
**平衡二叉树**。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。

举例如下：

![image-20211116175934210](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211116175934210.png)

当一棵二叉排序树不满足avl树时，可以通过左旋、右旋或双旋来将其转换为AVL树

### 03 旋转操作

#### 左旋转

当一棵树的右子树高度远高于左子树高度时，可以进行左旋处理。

##### 流程

![image-20211117100023496](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117100023496.png)

- 创建一个新的节点用来存储根节点的值
- 将新节点的左子节点设为原根节点的左子节点；新节点的右子节点设为原根节点的右子节点的左子节点
- 将原根节点的值修改为其右子节点的值
- 将原根节点的左子节点设为新节点；右子节点设为其右子节点的右子节点

##### 代码实现

因为AVL树就是在BST树的基础上新增功能，所以代码也可以在BST树的代码上新增

```java
class AVLTree{
	...
}

class avlNode{
	...
    private void leftRotate(){
        // 创建一个新的节点
        avlNode newNode = new avlNode(this.value);
        // 将新节点的左子节点设置为原根节点的左子节点
        newNode.left = this.left;
        newNode.right = this.right.left;
        // 将根节点的值修改为其右节点的值
        this.value = this.right.value;
        this.left = newNode;
        this.right = this.right.right;
    }
        // 获取左子树高度
    public int leftHeight(){
        if (left== null){
            return 0;
        }else{
            return left.height();
        }
    }
    // 获取右子树高度
    public int rightHeight(){
        if (right== null){
            return 0;
        }else{
            return right.height();
        }
    }
    // 需要先定义获取节点高度的方法
    public int height(){
        return Math.max(left == null?0: left.height(), right == null?0: right.height()) + 1;
    }
}
```

#### 右旋转

右旋转与左旋转原理相同

##### 原理：

![image-20211117105451215](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117105451215.png)

##### 代码：

```java
class avlNode{
    ...
	// 右旋
    private void rightRotate(){
        avlNode newNode = new avlNode(this.value);
        newNode.right = this.right;
        newNode.left = this.left.right;
        this.value = this.left.value;
        this.left = this.left.left;
        this.right = newNode;
    }
}
```

#### 双旋转

当出现下面这种树的时候，即使左旋或者右旋都不能转换成AVL树：

![image-20211117105529978](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117105529978.png)

这种情况就是因为，当需要右旋时，左子树的左子节点高度小于右子节点高度；当需要左旋时，右子树的左子节点高度大于右子节点高度。因此，需要在对树进行左旋或右旋时，做一个相应的左子或右子树高度判断。

**如果右旋时，根节点的左子节点的左子树高度小于右子树高度，就对根节点的左子树进行左旋操作**。反之同理。

而且**旋转操作应该在树创建完成的时候就进行**。



#### 最终代码实现

```java
class avlNode{
	...
	// 左旋
    private void leftRotate(){
        // 创建一个新的节点
        avlNode newNode = new avlNode(this.value);
        // 将新节点的左子节点设置为原根节点的左子节点
        newNode.left = this.left;
        newNode.right = this.right.left;
        // 将根节点的值修改为其右节点的值
        this.value = this.right.value;
        this.left = newNode;
        this.right = this.right.right;
    }
    // 右旋
    private void rightRotate(){
        avlNode newNode = new avlNode(this.value);
        newNode.right = this.right;
        newNode.left = this.left.right;
        this.value = this.left.value;
        this.left = this.left.left;
        this.right = newNode;
    }
    // 获取左子树高度
    public int leftHeight(){
        if (left== null){
            return 0;
        }else{
            return left.height();
        }
    }
    // 获取右子树高度
    public int rightHeight(){
        if (right== null){
            return 0;
        }else{
            return right.height();
        }
    }
    // 需要先定义获取节点高度的方法
    public int height(){
        return Math.max(left == null?0: left.height(), right == null?0: right.height()) + 1;
    }
    public void add(avlNode node){
        if (node == null){
            return;
        }
        if (node.value < this.value){
            if (this.left == null){
                this.left = node;
            }else{
                this.left.add(node);
            }
        }else{
            if (this.right == null){
                this.right = node;
            }else{
                this.right.add(node);
            }
        }
        // 应该在一棵树创建完成的时候就进行判断是否需要左旋或者右旋
        if (this.leftHeight() > this.rightHeight() + 1){
            if (this.left.leftHeight() < this.left.rightHeight()){
                // 如果当前节点的左子节点的右子节点高度大于左子节点高度，就需要先对左子树进行左旋
                this.left.leftRotate();
            }
            this.rightRotate();
        }
        if (this.rightHeight() > this.leftHeight() + 1){
            if (this.right.leftHeight() > this.right.rightHeight()){
                this.right.rightRotate();
            }
            this.leftRotate();
        }
    }
}
```



# 三、多路查找树

### 二叉树

#### 二叉树问题分析

二叉树需要加载到内存的，如果二叉树的节点少，没有什么问题，但是如果二叉树的节点很多(比如 1 亿)， 就 存在如下问题:

问题 1：在构建二叉树时，需要多次进行 i/o 操作(海量数据存在数据库或文件中)，节点海量，构建二叉树时， 速度有影响。

问题 2：节点海量，也会造成二叉树的高度很大，会降低操作速度。

#### 多叉树

在二叉树中，每个节点有数据项，最多有两个子节点。如果允许每个节点可以有更多的数据项和更多的子节点， 就是多叉树

### 2-3树

#### 2-3 树是最简单的 B 树结构, 具有如下特点：

-  2-3 树的所有叶子节点都在同一层.(只要是 B 树都满足这个条件)
- 有两个子节点的节点叫二节点，二节点要么没有子节点，要么有两个子节点.
- 有三个子节点的节点叫三节点，三节点要么没有子节点，要么有三个子节点
- 2-3 树是由二节点和三节点构成的树

#### 2-3 树应用案例

将数列{16, 24, 12, 32, 14, 26, 34, 10, 8, 28, 38, 20} 构建成 2-3 树，并保证数据插入的大小顺序。

![image-20211117115119163](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117115119163.png)

在构建过程中，每一步都要满足2-3树的要求，为满足要求而做相应的调整。

#### 其它说明 

除了 23 树，还有 234 树等，概念和 23 树类似，也是一种 B 树。 如图:

![image-20211117115222342](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117115222342.png)



### B树、B+树、B*树

#### B 树的介绍

如下图所示就是一个B树：

![image-20211117115312018](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117115312018.png)

说明：

- B 树的阶：节点的最多子节点个数。比如 2-3 树的阶是 3，2-3-4 树的阶是 4

- B-树的搜索，从根结点开始，对结点内的关键字（有序）序列进行二分查找，如果命中则结束，否则进入查询 关键字所属范围的儿子结点；重复，直到所对应的儿子指针为空，或已经是叶子结点

- **关键字集合分布在整颗树中, 即叶子节点和非叶子节点都存放数据**.

- 搜索有可能在非叶子结点结束
-  其**搜索性能等价于在关键字全集内做一次二分查找**

#### B+树的介绍

B+树是 B 树的变体，也是一种多路搜索树。

![image-20211117115554408](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117115554408.png)

说明：

- B+树的搜索与 B 树也基本相同，区别是 B+树只有达到叶子结点才命中（B 树可以在非叶子结点命中），其性 能也等价于在关键字全集做一次二分查找 

- **所有关键字都出现在叶子结点的链表中（即数据只能在叶子节点【也叫稠密索引】），且链表中的关键字(数据) 恰好是有序的。** 

- 不可能在非叶子结点命中 

- **非叶子结点相当于是叶子结点的索引（稀疏索引）**，叶子结点相当于是存储（关键字）数据的数据层

- 更适合文件索引系统 

- B 树和 B+树各有自己的应用场景，不能说 B+树完全比 B 树好，反之亦然.

#### B*树的介绍

B*树是 B+树的变体，在 B+树的**非根和非叶子结点**再增加指向兄弟的指针

![image-20211117115818100](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211117115818100.png)

说明：

- B**树定义了非叶子结点关键字个数至少为(2/3)* * M，即块的最低使用率为 2/3，而 B+树的块的最低使用率为的 1/2。 

- 从第 1 个特点我们可以看出，B*树分配新结点的概率比 B+树要低，空间使用率更高



# 四、图

## 图的基本介绍

### 为什么用图

 当我们需要表示多对多的关系时， 这里我们就用到了图。

### 图的基本概念

顶点（vertex）、边（edge）、路径、无向图、有向图、带权图

### 图的表示方式

#### 邻接矩阵

邻接矩阵是表示图形中顶点之间相邻关系的矩阵，对于 n 个顶点的图而言，矩阵是的 row 和 col 表示的是 1....n个点。

![image-20211118152652518](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211118152652518.png)

#### 邻接表

- 邻接矩阵需要为每个顶点都分配 n 个边的空间，其实有很多边都是不存在,会造成空间的一定损失 。

- 邻接表的实现**只关心存在的边，不关心不存在的边**。因此没有空间浪费，邻接表由数组+链表组成。、

![image-20211118152759130](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211118152759130.png)



## 图的简单入门案例

要求: 代码实现如下图结构：

![image-20211118152832664](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211118152832664.png)

```java
package graph;

import java.util.ArrayList;
import java.util.Arrays;

public class GraphDemo {
    private ArrayList<String> vertexList;
    private int[][] weightMatrix;
    private int edgeNum;
    public static void main(String[] args) {
        String vertex[] = {"A","B","C","D","E"};
        GraphDemo graphDemo = new GraphDemo(vertex.length);
        for (String vtx:vertex){
            graphDemo.addVertex(vtx);
        }
        graphDemo.addEdge(0,1,1);
        graphDemo.addEdge(0, 2, 1); //
        graphDemo.addEdge(1, 2, 1); //
        graphDemo.addEdge(1, 3, 1); //
        graphDemo.addEdge(1, 4, 1); //
        graphDemo.showGraph();
    }
    public int getVertexNum(){// 查看图的节点个数
        return vertexList.size();
    }
    public int getEdgeNum(){// 查看边的数量
        return edgeNum;
    }
    public String getVertex(int idx){// 查看下标对应的节点
        return vertexList.get(idx);
    }
    public int getWeight(int v1,int v2){// 查看边的权值
        return weightMatrix[v1][v2];
    }
    public void showGraph(){// 输出图的邻接矩阵
        for (int[] list:weightMatrix){
            System.out.println(Arrays.toString(list));
        }
    }
    public GraphDemo(int n) {// 构造器
        this.vertexList = new ArrayList<String>(n);
        this.weightMatrix = new int[n][n];
        this.edgeNum = 0;
    }
    public void addVertex(String vertex){//添加节点
        vertexList.add(vertex);
    }
    public void addEdge(int v1, int v2, int weight){ // 添加边
        weightMatrix[v1][v2] = weight;
        weightMatrix[v2][v1] = weight;
        edgeNum++;
    }
}
```

## 深度优先遍历

### 基本思想

1. 深度优先遍历，从初始访问结点出发，初始访问结点可能有多个邻接结点，深度优先遍历的策略就是首先访问 第一个邻接结点，然后再以这个被访问的邻接结点作为初始结点，访问它的第一个邻接结点。可以这样理解： **每次都在访问完当前结点后首先访问当前结点的第一个邻接结点（代码中的getFirstNeighbor方法）。** 

2) 我们可以看到，这样的访问策略是优先往纵向挖掘深入，而不是对一个结点的所有邻接结点进行横向访问。
2) 显然，深度优先搜索是一个递归的过程

### 步骤

1. 访问初始结点 v，并标记结点 v 为已访问。

2. 查找结点 v 的第一个邻接结点 w。

3. 若 w 存在，则继续执行 4，如果 w 不存在，则回到第 1 步，将从 v 的下一个结点继续（需要判断v下一节点是否被访问）。 

4. 若 w 未被访问，对 w 进行深度优先遍历递归（即把 w 当做另一个 v，然后进行步骤 123，也就是做递归）。 

5. 若w被访问，查找结点 v 的 w 邻接结点的下一个邻接结点，并赋值为w，转到步骤 3。

```markdown
伪代码
函数dfs（index）：
	1.对index处的节点执行相应操作（输出或操作）
	2.将index处的节点修改为已被访问
	3.查找index的第一个邻接节点w
	while(w存在){
        if w未被访问：
            dfs（w）
        else w被访问：
            查找index的当前邻接节点w后面的邻接节点，赋值给w
    }
真正的dfs()：
for遍历图中的每个节点：
	if 当前节点未被访问：
		dfs（当前节点）
```

### 代码实现

```python
    // 重载dfs，并且保证递归的dfs陷入死胡同结束后，能回到起点遍历下去
    public void dfs(){
        for (int i=0; i<vertexList.size();i++){
            if (!isValued[i]){
                dfs(isValued,i);
            }
        }
    }
    // 深度优先遍历
    public void dfs(boolean[] isValued,int index){
        System.out.println(vertexList.get(index));
        isValued[index] = true;
        // 寻找节点index的第一个邻接节点
        int firstNeighbor = getFirstNeighbor(index);
        while (firstNeighbor!=-1){

            if (!isValued[firstNeighbor]){ // 如果index的第一个邻接节点未被访问，就用这个未被访问的邻接节点递归
                dfs(isValued,firstNeighbor);
            }
            // 当index的第一个邻接节点已经被访问过了，那就应该查找index节点的第二个邻接节点
            firstNeighbor = getNextNeighbor(index, firstNeighbor);

            //如果这个节点不存在就应该，回到index节点的
        }

    }

    // 查找给定节点的第一个邻接节点（用在刚遍历输出一个节点后，找他的下一个节点）
    public int getFirstNeighbor(int j){
        for (int i=0; i<vertexList.size();i++){
            if (weightMatrix[j][i]>0){
                return i;
            }
        }
        return -1;
    }

    // 给定一个节点index和他的一个邻接节点firstNeighbor，查找index的下一个邻接节点
    public int getNextNeighbor(int index,int firstNeighbor){
        for (int i=firstNeighbor+1; i<vertexList.size(); i++){
            if (weightMatrix[index][i]>0){
                return i;
            }
        }
        return -1;
    }
```

## 广度优先算法

### 算法思想

 类似于一个**分层搜索**的过程，广度优先遍历需要使用一个队列以保持访问过的结点的顺序，以便按这个顺序来 访问这些结点的邻接结点。

### 步骤

1) 访问初始结点v 并标记结点v 为已访问。
2) 结点v 入队列

3) 当队列非空时，继续执行，否则算法结束。
4) 出队列，取得队头结点u。
5) 查找结点u 的第一个邻接结点w。
6) 若结点u 的邻接结点w 不存在，则转到步骤3；否则循环执行以下三个步骤：
6.1 若结点w 尚未被访问，则访问结点w 并标记为已访问。
6.2 结点w 入队列
6.3 查找结点u 的继w 邻接结点后的下一个邻接结点w，转到步骤6。

```markdown
伪代码
bfs(index):
	（index节点的初始操作）
	1.先输出index节点并标为以访问，
	2.将index节点入队列
	
	（循环迭代操作）
	while(队列不为空)： 
		1.取出并删除队列第一个元素记为u，查询出u的第一个邻接节点记为w
		while(wc)： -->【用于对当前节点做广度遍历，遍历完其所有邻接节点再退出】
			if(w未被访问)：
				输出w并将其标为已访问，将w入栈
			else(w已被访问)：
				查找u的邻接节点w后面的一个邻接节点并赋值为w
				
封装bfs():
    for(图节点中的每个元素)：-->【其实只要这个图没有孤立点，就可以不用做循环，只用一个节点就可以遍历完整个图】
		if(当前节点未被访问)：
			bfs(当前节点)
```



### 代码实现

```java
    public void bfs(){
        visitNum = 0;	// 在类里面定义了这个参数,统计已被遍历节点数，用于优化遍历
        isValued = new boolean[vertexList.size()];
        for(int i=0; i<vertexList.size();i++){
            if(!isValued[i]){
                bfs(isValued,i);
            }
        }
    }
    // 广度优先遍历
    public void bfs(boolean[] isValued,int index){
        int u;
        int w;
        System.out.println(vertexList.get(index));
        isValued[index] = true;
        visitNum++;
        LinkedList queue = new LinkedList();
        queue.addLast(index);	// 当一个节点被遍历了，就将他入队，加到最后
        while (!queue.isEmpty() && visitNum!=getVertexNum()){
            u = (Integer) queue.removeFirst(); // 取出队列头部的节点，以它为中心进行广度遍历
            w = getFirstNeighbor(u); // 先获取中心节点的第一个节点
            while (w!=-1){
                if (!isValued[w]){
                    // 经过两重判断后，遍历它。下面这几步是固定操作
                    System.out.println(vertexList.get(w));	
                    isValued[w] = true;
                    visitNum++;
                    queue.addLast(w);
                }else{
                    w = getNextNeighbor(u,w);
                }
            }
        }
    }
```



















# 五、常用算法设计

## 01 二分查找算法

### 使用递归

```java
public class BinarySearchNoRecur {
    public static void main(String[] args) {
        int[] arr = {1,3,10,11,67,100};
        int index = binarySearchNoRecur(arr,100);
        System.out.println("index="+index);
    }
    // 二分查找非递归方法
    public static int binarySearchNoRecur(int[] arr, int findVal){
        int left = 0;
        int right = arr.length-1;
        while (left <= right){
            int mid = (left+right) / 2;
            if (findVal == arr[mid]){
                return mid;
            }else if(findVal > arr[mid]){
                left = mid + 1;
            }else{
                right = mid - 1;
            }
        }
        return -1;
    }
}
```

### 非递归方法

```java
public class BinarySearch {
    public static void main(String[] args) {
        int arr[] = {1, 8, 10, 89,1000,1000, 1234 };
        int resIndex = binarySearch(arr, 1000);
        System.out.println("resIndex=" + resIndex);
    }
    // 重载方法
    public static int binarySearch(int[] arr, int findVal){
        return binarySearch(arr,0,arr.length-1,findVal);
    }
    // 二分查找递归方法
    public static int binarySearch(int[] arr,int left,int right, int findVal){
        if (left > right){
            return -1;
        }
        int mid = (left + right) / 2;
        if (findVal == arr[mid]){
            return mid;
        }else if (findVal > arr[mid]){
            left = mid + 1 ;
            return binarySearch(arr,left,right,findVal);
        }else{
            right = mid -1;
            return binarySearch(arr, left, right, findVal);
        }
    }
}
```

## 02 分治算法

### 分治算法步骤

分治算法就三大步骤：

分：将原问题分解成若干个规模较小的问题，每个问题相互独立，且与原问题形式相同的子问题

治：规模较小的子问题容易被解决时就直接解决，否则就递归解决各个子问题

合并：将子问题的解合成原问题的解

### 分治算法设计模式

```java
对于分治问题P：
if |P| < n0:
	基本问题：调用能直接解决小规模问题的子算法
// 将P分解成k个小问题P1,P2...Pk ：注意这k个问题是同一级且相互独立的
for i in [1 to k]：
	Divide-and-Conquer: 对每个子问题都调用递归，每个递归都是到问题足够小时直接解决，否则继续递归
Merge：将k个子问题合并成原问题的解
return
```

### 以汉诺塔为例分析

#### 分析

对于汉诺塔，无论有多少个盘，都可以分解为：

**基本情况(有1个盘)**：

只有一个盘时：直接将这个盘从A移动到C

**一般情况(有n个盘)**：

- 先将上面的n-1个盘从A移到B -->【子问题1】不足够小，需要**递归解决**
- 再将最下面的盘从A移到C -->【子问题2】足够小，可以直接解决
- 最后将那n-1个盘从B移到C -->【子问题3】不足够小，需要**递归解决**

#### 代码实现

```java
public class divideAndConquer {
    public static void main(String[] args) {
        hanoiTower(5,'a','b','c');
    }
    public static void hanoiTower(int num, char a, char b, char c){
        if (num == 1){ // 是否为基本情况的判别：盘数是否为1
            System.out.println("第1个盘从"+a+"到"+c);  // 直接解决基本情况的子算法
        }else{
            // 解决一般情况的子问题
            hanoiTower(num-1,a,c,b);	// 子问题1：将上面的n-1个盘，从a移到b
            System.out.println("第"+num+"个盘从"+a+"到"+c);	// 子问题2：将最下面的盘从A移到C
            hanoiTower(num-1,b,a,c);	// 子问题3：将那n-1个盘从b移到c
        }
    }
}
```

#### 总结

对于一些复杂问题，如果可以用分治算法解决，分析到上面这样的程度就够了，不要再继续思考下去，不然容易将问题想复杂，更难以解决。

问题的难点一般应该是：

- **怎样合理拆分出各个子问题**，能保证需要递归的部分就递归，不需要递归的地方直接执行
- 对于递归的子问题应该怎样考虑递归



## 03 贪心算法

贪婪算法(贪心算法)是指在对问题进行求解时，在**每一步选择中都采取最好或者最优(即最有利)的选择**，从而 希望能够导致结果是最好或者最优的算法。贪婪算法所得到的结果不一定是最优的结果(有时候会是最优解)，但是都是相对近似(接近)最优解的结果。

### 应用案例：集合覆盖

#### **问题描述**：

假设存在如下表的需要付费的广播台，以及广播台信号可以覆盖的地区。 如何选择最少的广播台，让所有 的地区都可以接收到信号。

![image-20211119172115363](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211119172115363.png)

#### **步骤：**

- 遍历所有的广播电台, 找到一个覆盖了最多未覆盖的地区的电台（此电台可能包含一些已覆盖的地区）
- 将这个电台加入到一个集合中(比如 ArrayList), 想办法把该电台覆盖的地区在下次比较时去掉。
- 重复上面两步直到覆盖全部地区

#### 代码实现

```java
package algorithm;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;

public class greedy {
    public static void main(String[] args) {
        //定义一个hashmap的list，用来存放key和value
        HashMap<String,HashSet<String>> allChoice = new HashMap<>();
        // 创建一个hashset来做key和value，并添加数据
        HashSet<String> hashSet1 = new HashSet<String>();
        hashSet1.add("北京");
        hashSet1.add("上海");
        hashSet1.add("天津");
        HashSet<String> hashSet2 = new HashSet<String>();
        hashSet2.add("广州");
        hashSet2.add("北京");
        hashSet2.add("深圳");
        HashSet<String> hashSet3 = new HashSet<String>();
        hashSet3.add("成都");
        hashSet3.add("上海");
        hashSet3.add("杭州");
        HashSet<String> hashSet4 = new HashSet<String>();
        hashSet4.add("上海");
        hashSet4.add("天津");
        HashSet<String> hashSet5 = new HashSet<String>();
        hashSet5.add("杭州");
        hashSet5.add("大连");
        allChoice.put("k1",hashSet1);
        allChoice.put("k2",hashSet2);
        allChoice.put("k3",hashSet3);
        allChoice.put("k4",hashSet4);
        allChoice.put("k5",hashSet5);
        
        // 创建所需所有地区的hashset
        HashSet<String> allAreas = new HashSet<>();
        for (String key:allChoice.keySet()){
            allAreas.addAll(allChoice.get(key));
        }
        String maxKey = null; // 用来存放含有最多可选择值的key
        HashSet<String> tempChoice = new HashSet<>();	// 暂存选择
        HashSet<String> keySet = new HashSet<>();	// 用来存放选择的key
        while (allAreas.size() > 0){
            maxKey = null;
            // 要先找出有最多值的key
            for (String key: allChoice.keySet() ){
                tempChoice.clear();
                tempChoice.addAll(allChoice.get(key));
                tempChoice.retainAll(allAreas);
                //if中的判断条件tempChoice.size()> allChoice.get(maxKey).size()即为贪心
                if (tempChoice.size()>0 && (maxKey ==null || 
                                            tempChoice.size()> allChoice.get(maxKey).size())){
                    maxKey = key;
                }
            }
            allAreas.removeAll(allChoice.get(maxKey));
            keySet.add(maxKey);
        }
        System.out.println("应选择的地区为："+keySet);
    }
}
```

## 动态规划



## KMP算法

### 字符串的暴力匹配

只要未能匹配的，就回退到开始的地方，重新来：

```java
/**
     * 暴力匹配算法
     * @param str1 原字符串
     * @param str2 待匹配的字符串
     * @return 匹配到的第一次出现的索引
     */
    public static int violenceSearch(String str1,String str2){
        for (int i=0,j=0; i<str1.length(); i++){
            while (j>0 && str1.charAt(i) != str2.charAt(j)){
                i = i - j + 1;
                j = 0;
            }
            if (str1.charAt(i) == str2.charAt(j)){
                j++;
            }
            if (j == str2.length()){
                return i - j +1;
            }
        }
        return -1;
    }
```



### KMP算法思想

KMP算法就是在暴力匹配上的改进，当匹配到不同字符的时候，不应该回溯到本次匹配到的开头处。而是回溯：用当前已匹配的字符串长度减去待匹配字符串中当前未能匹配的字符前面一个字符的next值（也就是被匹配字符串的指针直接回退到其前面被匹配子字符串第一次出现的地方：

![image-20211120195619817](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211120195619817.png)

如上图所示是一个待匹配的字符串，在该字符串中，蓝色的两块是相同的子字符串。当在Pk处与原字符串某处的值不一样时，就将其回退到Pnext处，用Pnext的值与当前的原字符串中相应的字符匹配。而不用像暴力匹配一样，直接回到最开始Po处。

### KMP算法next数组的推导

![img](https://img-blog.csdn.net/20150812214857858)

next数组核心的部分就是如何回溯的问题，即回溯到哪里：

1.上面的图中，第一个k和第二个k是两串完全相同的匹配，所以next数组中Pj位置的前一个的值就是k。

2.现在两个指针分别都移动到了Pk和Pk，此时发现这两个值不等，必须将Pk处的指针做回溯，需要选择回溯的位置。

3.如果P(k-1)处的值不为零，说明在其前面还有与它匹配的子串；也就是P(j-1)处也与前面有匹配的子串。**所以目标是回到与P(j-1)处的小子串第一次发生第一次匹配时的位置**，用第一次的小子串的后一个来作为第一个指针用以和Pj比较。

4.但是P(j-1)处的小子串可能在前面出现了很多次，所以应该逐层递归回去，直到第一个出现的子串

> 如果出现了多层大小子串的嵌套，是从大到小逐层回溯的。



**下面考虑嵌套的情况**：

![image-20211120180413374](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211120180413374.png)

第一步：Pi和Pj先比较，发现不相同，则Pi需要回溯

第二步：通过i = Next(i-1)，第一次回溯到Ps处，然后和Pj比较。相等的话，Pj在Next数组中的值就直接是Ps的索引+1；不等的话还需要对Ps做回溯

第三步：此时回溯到第一个且是最小的一个子块，让Pm与Pj比较，如果相等就是Pm的索引+1；不相等的话，就会通过i = Next(i-1)回溯到最开始的位置，然后Pj的next值直接为0。

### 代码实现

```java
import java.util.Arrays;

public class KMP {
    public static void main(String[] args) {
        String str1 = "BBC ABCDAB ABCDABCDABDE";
        String str2 = "ABCDABD";
        int i = kmpSearch(str1, str2);
        System.out.println(i);

    }
    public static int kmpSearch(String str1, String str2){
        int[] next = kmpNext(str2);
        System.out.println(Arrays.toString(next));
        for (int i=0, j=0; j<str1.length();j++){    // i是str2中的指针，j是str1中的指针

            while (i > 0 && str1.charAt(j) != str2.charAt(i)){
                i = next[i-1];
            }

            if (str1.charAt(j) == str2.charAt(i)){
                i++;
            }
            if (i == str2.length()){
                return j - i+1;
            }
        }
        return -1;

    }
    /**
     * 获取子字符串的next表
     * @param str 输入的子字符串
     * @return 返回next数组
     */
    public static  int[] kmpNext(String str){
        int[] next = new int[str.length()];
        next[0] = 0;

        for (int i=0, j=1; j < str.length(); j++){
            while (i>0 && str.charAt(i) != str.charAt(j)){
                i = next[i-1];
            }
            if (str.charAt(i) == str.charAt(j)){
                i++;
            }
            next[j] = i;
        }
        return next;
    }
}
```

## 最小生成树问题

### 应用场景

![image-20211121162406507](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211121162406507.png)

1. 有胜利乡有7 个村庄(A, B, C, D, E, F, G) ，现在需要修路把7 个村庄连通

2. 各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里

3. 问：如何修路保证各个村庄都能连通，并且总的修建公路总里程最短?

  思路: 将10 条边，连接即可，但是总的里程数不是最小.

  正确的思路，就是尽可能的选择少的路线，并且每条路线最小，保证总里程数最少.

### 最小生成树

修路问题本质就是**最小生成树问题**， 先介绍一下最小生成树(Minimum Cost Spanning Tree)，简称MST。给定一个带权的无向连通图,如何**选取一棵生成树,使树上所有边上权的总和为最小,这叫最小生成树**。

生成树满足条件：

- N 个顶点，一定有N-1 条边

- 包含全部顶点

- N-1 条边都在图中

如图所示即为一个完全树的生成树：

![image-20211121162736026](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211121162736026.png)

**求最小生成树的算法主要是普里姆算法和克鲁斯卡尔算法**

### prim算法介绍

普利姆(Prim)算法求最小生成树，也就是在包含n 个顶点的连通图中，找出只有(n-1)条边包含所有n 个顶点的
连通子图，也就是所谓的极小连通子图。

prim算法步骤：

- 定义一个G=(V,E)是连通网，T=(U,D)是最小生成树，V,U 是顶点集合，E,D 是边的集合；visited表示各个顶点时候被访问过。

- 从一个顶点u开始构造最小生成树：将u从V中取出放到U中，并将visited[u]=1
- 对于U中的顶点，从V中找到一个与**它们相连的、边的权重最小、且未被访问的节点**ui，将节点ui放到U中，将最小权重放到D中，并将visited[ui]=1。
- 重复上面的两步，直到U中节点数与V中节点数相同为止，此时D中有n-1条边，此时的T即为最小生成树。

图解：

![image-20211121163727029](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211121163727029.png)

### prim算法代码实现

```java
import java.util.Arrays;

public class primAlgorithm {
    public static void main(String[] args) {
        char[] data = new char[]{'A','B','C','D','E','F','G'};
        int vertex = data.length;
        MGraph mGraph = new MGraph(vertex);
        MinTree minTree = new MinTree();
        int[][] weight=new int[][]{
                {10000,5,7,10000,10000,10000,2},
                {5,10000,10000,9,10000,10000,3},
                {7,10000,10000,10000,8,10000,10000},
                {10000,9,10000,10000,10000,4,10000},
                {10000,10000,8,10000,10000,5,4},
                {10000,10000,10000,4,5,10000,6},
                {2,3,10000,10000,4,6,10000},};
        minTree.createGraph(mGraph,vertex,data,weight);
        minTree.showGraph(mGraph);
        minTree.prim(mGraph,0);
    }
}
// 创建最小生成树的类
class MinTree{
    // 先创建一个图对象
    public void createGraph(MGraph mGraph,int vertex, char[] data, int[][] weight){
        int i,j;
        for (i=0; i< vertex;i++){
            mGraph.data[i] = data[i];
            for (j=0; j< vertex; j++){
                mGraph.weight[i][j] = weight[i][j];
            }
        }
    }

    // 定义一个显示图的方法
    public void showGraph(MGraph mGraph){
        for (int i=0; i<mGraph.vertex; i++){
            System.out.println(Arrays.toString(mGraph.weight[i]));
        }
    }
    /**
     * 定义prim算法
     * @param mGraph 待操作的图对象
     * @param v 需要生成一棵最小数的起点位置
     */
    public void prim(MGraph mGraph,int v){
        // 定义一个数组，用来表示该节点是否被访问：0表示未被访问，1表示已被访问
        int[] isVisited = new int[mGraph.vertex];
        isVisited[v] = 1;
        // 最外一层循环表示生成mGraph.vertex-1条边，也就是最小生成树的要求
        for (int k=1; k < mGraph.vertex;k++){
            // 定义一个数用来存放最小权重
            int minWeight = 10000;
            // 定义两个数用来存获取到最小weight时的两个顶点的索引
            int h1 = -1;
            int h2 = -1;
            for (int i=0; i< mGraph.vertex; i++){// i代表访问过的节点
                for (int j=0; j< mGraph.vertex; j++){// j表示未被访问过的节点
                    if (isVisited[i]==1 && isVisited[j]==0 && mGraph.weight[i][j] < minWeight){
                        minWeight = mGraph.weight[i][j];
                        h1 = i;
                        h2 = j;
                    }
                }
            }
            System.out.println("这一轮最小边是节点"+h1+"和节点"+h2+"的边，权重为："+minWeight);
            isVisited[h2] = 1;
        }
    }
}

// 创建一个图的entity
class MGraph{
    int vertex;
    char[] data;
    int[][] weight;

    public MGraph(int vertex) {
        this.vertex = vertex;
        this.data = new char[vertex];
        this.weight = new int[vertex][vertex];
    }
}
```

> 代码中使用了三层for循环，是因为在遍历中，已访问节点和未访问节点的数量是不定的，需要对所有已访问的节点遍历与其连接的未访问节点，并找出其中最小的边。因此里面选用了两层n循环，分别用以表示对每个访问了的节点都遍历所有未访问的边。

### 克鲁斯卡尔算法介绍

1) 克鲁斯卡尔(Kruskal)算法，是用来求加权连通图的最小生成树的算法。
2) 基本思想：按照权值从小到大的顺序选择n-1 条边，并保证这n-1 条边不构成回路
3) 具体做法：首先构造一个只含n 个顶点的森林，然后依权值从小到大从连通网中选择边加入到森林中，并使森
    林中不产生回路，直至森林变成一棵树为止。

#### kruskal图解

![image-20211121184226788](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211121184226788.png)

> kruscal算法两个关键点：
>
> - 将边按权值进行排序
> - 将边添加到最小生成树时，怎样判断是否形成环：用**union/find算法**

### 克鲁斯卡尔算法代码实现

#### 流程

1.kruskal构造器。属性：边数、顶点数、邻接矩阵。邻接矩阵的显示

2.定义一个边类，对边进行排序，获取邻接矩阵中的边，根据下标获取顶点

3.获取每个顶点的终点

4.kruskal算法：获取边的数组，然后排序；对排好序的边数组进行遍历，每次遍历都取出边的两个顶点，获取顶点的终点，终点不同就取一条边

#### 代码

```java
import java.util.Arrays;

public class kruskal {
    public int edgeNum;
    public char[] vertex;
    public int[][] weight;
    public static final int INF = Integer.MAX_VALUE;
    public static void main(String[] args) {
        char[] vertex = new char[]{'A','B','C','D','E','F','G'};
        int weight[][] = {
                /*A*//*B*//*C*//*D*//*E*//*F*//*G*/
                /*A*/ { 0, 12, INF, INF, INF, 16, 14},
                /*B*/ { 12, 0, 10, INF, INF, 7, INF},
                /*C*/ { INF, 10, 0, 3, 5, 6, INF},
                /*D*/ { INF, INF, 3, 0, 4, INF, INF},
                /*E*/ { INF, INF, 5, 4, 0, 2, 8},
                /*F*/ { 16, 7, 6, INF, 2, 0, 9},
                /*G*/ { 14, INF, INF, INF, 8, 9, 0}};
        kruskal kruskal1 = new kruskal(vertex,weight);
        EdgeData[] edgeData = kruskal1.kruskalAlgorithm();
        for (int i=0 ; i< edgeData.length; i++){
            System.out.println(edgeData[i]);
        }
    }
    // 定义构造器
    public kruskal(char[] vertex, int[][] weight) {
        // 获取边和权重
        this.vertex = vertex;
        this.weight = weight;
        // 获取边的数量
        for (int i=0; i< weight.length;i++){
            for (int j=i+1; j < weight.length; j++){
                if (weight[i][j] != INF){
                    this.edgeNum++;
                }
            }
        }
    }
    //查看邻接矩阵
    public void show(){
        for (int i=0; i< weight.length; i++){
            System.out.println(Arrays.toString(weight[i]));
        }
    }
    // kruskal算法
    public EdgeData[] kruskalAlgorithm(){
        // 先获取整个图的边,将边进行排序
        EdgeData[] edgeData = getEdge();
        sortEdge(edgeData);

        int[] ends = new int[vertex.length];
        EdgeData[] resultEdge = new EdgeData[vertex.length-1];
        int index = 0;
        // 对排好序的边进行遍历
        for (int i=0; i < edgeData.length; i++){
            // 对于每一条边，需要获取其两个顶点的终点值
            int v1 = getEnds(ends,getVertex(edgeData[i].start));
            int v2 = getEnds(ends,getVertex(edgeData[i].end));
            if (v1 != v2){
                ends[v1] = v2;
                resultEdge[index++] = edgeData[i];
                System.out.println(Arrays.toString(ends));
            }
        }
        System.out.println(Arrays.toString(ends));
        return resultEdge;
    }
    // 获取顶点的终点值
    public int getEnds(int[] ends, int idx){
        while (ends[idx] != 0){
            idx = ends[idx];
        }
        return idx;
    }
    // 定义一个获取图中所有边的数组的方法
    public EdgeData[] getEdge(){
        EdgeData edgeData;
        EdgeData[] edges = new EdgeData[edgeNum];
        int index = 0;
        for (int i=0; i< weight.length; i++){
            for (int j=i+1; j< weight.length; j++){
                if(weight[i][j] != INF){
                    edgeData = new EdgeData(vertex[i],vertex[j], weight[i][j]);
                    edges[index] = edgeData;
                    index++;
                }
            }
        }
        return edges;
    }
    // 定义一个将边进行排序的方法
    public void sortEdge(EdgeData[] edgeData){
        // 这里用冒泡排序
        for (int i=0; i < edgeData.length; i++){
            for (int j=i+1; j < edgeData.length; j++){
                if (edgeData[i].edge > edgeData[j].edge){
                    EdgeData temp = edgeData[i];
                    edgeData[i] = edgeData[j];
                    edgeData[j] = temp;
                }
            }
        }
    }
    // 先定义一个根据索引获取顶点char的方法
    public int getVertex(char ch){
        for (int i=0; i<vertex.length;i++){
            if (vertex[i]==ch){
                return i;
            }
        }
        return -1;
    }
}

class EdgeData{
    char start;
    char end;
    int edge;
    public EdgeData(char start, char end, int edge) {
        this.start = start;
        this.end = end;
        this.edge = edge;
    }
    @Override
    public String toString() {
        return "EdgeData{" +
                "start=" + start +
                ", end=" + end +
                ", edge=" + edge +
                '}';
    }
}
```

> kruskal算法难点就是各个顶点的终点这里。这一部分用到了union/find算法



## 最短路径问题

### 最短路径问题

![image-20211122142434968](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211122142434968.png)

1) 战争时期，胜利乡有7 个村庄(A, B, C, D, E, F, G) ，现在有六个邮差，从G 点出发，需要分别把邮件分别送到
    A, B, C , D, E, F 六个村庄
2) 各个村庄的距离用边线表示(权) ，比如A – B 距离5 公里
3) 问：如何计算出G 村庄到其它各个村庄的最短距离?，如G到D、G到C
4) 如果从其它点出发到各个点的最短距离又是多少?



### Dijkstra算法介绍

1) 设置出发顶点为v，顶点集合V{v1,v2,vi...}，v 到V 中各顶点的距离构成距离集合Dis，Dis{d1,d2,di...}，Dis
    集合记录着v 到图中各顶点的距离(到自身可以看作0，v 到vi 距离对应为di)
2) 从Dis 中选择值最小的di 并移出Dis 集合，同时移出V 集合中对应的顶点vi，此时的v 到vi 即为最短路径
3) 更新Dis 集合，更新规则为：比较v 到V 集合中顶点的距离值，与**v 通过vi 到V 集合中顶点的距离值**，**保留**
    **值较小的一个**(同时也应该更新顶点的前驱节点为vi，表明是通过vi 到达的)
4) 重复执行两步骤，直到最短路径顶点为目标顶点即可结束

![image-20211122144627635](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211122144627635.png)

### Dijkstra算法代码实现

1.创建图的类，属性为顶点和边

2.创建已访问顶点的类，属性为三个数组：已访问节点、前驱节点、距离数组

3.编写dijkstra算法：输入起始index，以index更新上面三个数组（封装一个方法），选择新的顶点来作为index（新顶点是未被访问过，且与起始点距离最小的一个，即getNewIndex方法），然后继续以新的节点来跟新上面三个数组

4.写以index更新数组的方法：遍历邻接矩阵中的index行（也就是遍历与其相连的节点），遍历中：获取当前节点与起始节点的距离（当前到index+index到起始：前者通过邻接矩阵获取，后者通过距离数组获取），判断当前节点是否访问过和距离是否小于距离数组中当前节点到起始节点的距离，是的话就更新距离和前驱节点，即update

```java
import java.util.Arrays;

public class Dijkstra {
    public static void main(String[] args) {
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65536;
        matrix[0]=new int[]{N,5,7,N,N,N,2};
        matrix[1]=new int[]{5,N,N,9,N,N,3};
        matrix[2]=new int[]{7,N,N,N,8,N,N};
        matrix[3]=new int[]{N,9,N,N,N,4,N};
        matrix[4]=new int[]{N,N,8,N,N,5,4};
        matrix[5]=new int[]{N,N,N,4,5,N,6};
        matrix[6]=new int[]{2,3,N,N,4,6,N};
        Graph graph = new Graph(vertex,matrix);
        graph.dijkstra(6);
        graph.show();
    }
}
// 定义图的类
class Graph{
    private char[] vertex;
    private int[][] matrix;
    private VisitedVertex vv;

    public Graph(char[] vertex,int[][] matrix){
        this.matrix = matrix;
        this.vertex = vertex;
    }
	// dijkstra算法
    public void dijkstra(int index){
        vv = new VisitedVertex(vertex.length, index);
        // 根据这个起始节点index来先做一次更新
        update(index);
        // 获取新的节点来循环操作
        for (int i=0; i< vertex.length; i++){
            index = vv.getNewIndex();
            update(index);
        }

    }
    // 以当前节点更新三个数组
    public void update(int index){
        for (int i=0; i<matrix[index].length; i++){
            // 获取当前节点到起始点的距离：当前节点到index的距离+index到起始点的距离
            int len = matrix[index][i] + vv.getDis(index);
            // 如果当前节点未被访问，且len小于dis，就更新
            if (vv.getIsVisit(i)==0 && len < vv.getDis(i)){
                // 先更新距离
                vv.updateDis(len,i);
                // 再更新前驱节点
                vv.updatePre(i,index);
            }
        }
    }
    public void show(){
        vv.show();
    }

}
// 定义已访问节点类：定义一些方法
class VisitedVertex{
    private int[] visited_vertex;   // 已访问过的节点
    private int[] pre_vertex;   // 当前节点的前驱节点
    private int[] dis;  // 当前节点与起始节点的距离
    final int N = 65535;

    // 构造器，需要传入节点个数和起始节点
    public VisitedVertex(int vertexNum,int index){
        visited_vertex = new int[vertexNum];
        visited_vertex[index] = 1;
        pre_vertex = new int[vertexNum];
        dis = new int[vertexNum];
        Arrays.fill(dis,N);
        dis[index] = 0;
    }
    // 返回index到起始点的距离
    public int getDis(int index){
        return dis[index];
    }
    // 返回当前节点是否被访问
    public int getIsVisit(int index){
        return visited_vertex[index];
    }
    public void updateDis(int len, int index){
        dis[index] = len;
    }
    public void updatePre(int index,int pre){
        pre_vertex[index] = pre;
    }
    public int getNewIndex(){
        int min = 65535;
        int idx = 0;
        for (int i=0 ; i<visited_vertex.length; i++){
            if (visited_vertex[i] ==0 && dis[i] < min){
                min = dis[i];
                idx = i;
            }
        }
        visited_vertex[idx] = 1;
        return idx;
    }

    public void show(){
        System.out.println("=================");
        for (int i : visited_vertex){
            System.out.println(i+" ");
        }
        System.out.println();
        for (int i:pre_vertex){
            System.out.println(i+" ");
        }
        System.out.println();
        for(int i : dis) {
            System.out.print(i + " ");
        }
        System.out.println();
        char[] vertex = {'A', 'B', 'C', 'D', 'E', 'F', 'G'};
        int count = 0;
        for (int i: dis){
            if (i!=65535){
                System.out.println(vertex[count]+"("+i+")");
            }else{
                System.out.println("N");
            }
            count++;
        }
        System.out.println();
    }
}
```

> 核心方法就两个：
>
> - 更新当前节点的情况，即update方法
> - 获取下一个节点，来作为跟新的节点，即getNewIndex方法



### Floyd算法介绍

#### floyd算法与dijkstra算法比较

弗洛伊德算法(Floyd)计算**图中各个顶点之间的最短路径**。迪杰斯特拉算法用于计算**图中某一个顶点到其他顶点的最短路径**。

弗洛伊德算法VS 迪杰斯特拉算法：迪杰斯特拉算法通过选定的被访问顶点，求出从出发访问顶点到其他顶点
的最短路径；弗洛伊德算法中每一个顶点都是出发访问点，所以需要将每一个顶点看做被访问顶点，求出从每
一个顶点到其他顶点的最短路径。

#### floyd算法解析

设置顶点vi 到顶点vk 的最短路径已知为Lik，顶点vk 到vj 的最短路径已知为Lkj，顶点vi 到vj 的路径为Lij，**则vi 到vj 的最短路径为：min((Lik+Lkj),Lij)**，vk 的取值为图中所有顶点，则可获得vi 到vj 的最短路径。

#### 算法步骤

1. 根据图生成一个距离表和前驱关系表，如下图所示：

![image-20211122180838462](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211122180838462.png)

![image-20211122180857556](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211122180857556.png)

2. 以A 顶点作为中间顶点是，B->A->C 的距离由N->9，同理C 到B；C->A->G 的距离由N->12，同理G 到C，更新后两个表如下：

![image-20211122180924701](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211122180924701.png)

3. 更换中间顶点，循环执行操作，直到所有顶点都作为中间顶点更新后，计算结束

### Floyd算法代码实现

1.创建图的类，属性：节点、距离、前驱节点表

2.编写floyd算法。对每个节点都作为中间顶点进行遍历：再写两个for循环，一个作为前顶点遍历，一个作为后顶点遍历，计算从前顶点到中间节点+中间节点到后顶点的距离，如果距离小于前顶点到后顶点的距离，就跟新前后顶点的距离，并跟新前驱节点为中间节点。

```java
import java.util.Arrays;

public class Floyd {
    public static void main(String[] args) {
        // 测试看看图是否创建成功
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
//创建邻接矩阵
        int[][] matrix = new int[vertex.length][vertex.length];
        final int N = 65535;
        matrix[0] = new int[] { 0, 5, 7, N, N, N, 2 };
        matrix[1] = new int[] { 5, 0, N, 9, N, N, 3 };
        matrix[2] = new int[] { 7, N, 0, N, 8, N, N };
        matrix[3] = new int[] { N, 9, N, 0, N, 4, N };
        matrix[4] = new int[] { N, N, 8, N, 0, 5, 4 };
        matrix[5] = new int[] { N, N, N, 4, 5, 0, 6 };
        matrix[6] = new int[] { 2, 3, N, N, 4, 6, 0 };

        FGraph fGraph = new FGraph(vertex.length, matrix,vertex);
        fGraph.floyd();
        fGraph.show();
    }
}

class FGraph{
    private char[] vertex;
    private int[][] matrix;
    private int[][] preVertex;

    public FGraph(int vertexLen, int[][] matrix, char[] vertex){
        this.vertex = vertex;
        this.matrix = matrix;
        preVertex = new int[vertexLen][vertexLen];
        for (int i=0; i<vertexLen; i++){
            Arrays.fill(preVertex[i],i);
        }
    }

    public void floyd(){
        for (int k=0; k< vertex.length; k++){   // k是中间节点
            for (int i=0; i< vertex.length; i++){   //i是前节点
                for (int j=0; j< vertex.length; j++){   // j是后节点
                    int len = matrix[i][k] + matrix[k][j];
                    if (len < matrix[i][j]){
                        matrix[i][j] = len;
                        preVertex[i][j] = preVertex[k][j];
                    }
                }
            }
        }
    }

    // 显示pre 数组和dis 数组
    public void show() {
        //为了显示便于阅读，我们优化一下输出
        char[] vertex = { 'A', 'B', 'C', 'D', 'E', 'F', 'G' };
        for (int k = 0; k < matrix.length; k++) {
            // 先将pre 数组输出的一行
            for (int i = 0; i < matrix.length; i++) {
                System.out.print(vertex[preVertex[k][i]] + " ");
            }
            System.out.println();
            // 输出dis 数组的一行数据
            for (int i = 0; i < matrix.length; i++) {
                System.out.print("("+vertex[k]+"到"+vertex[i]+"的最短路径是" + matrix[k][i] + ") ");
            }
            System.out.println();
            System.out.println();
        }
    }
}

```

> **这个前驱节点表好像不要也可以？，如果只需要最终结果，而不需要过程的话。**、
>
> 前驱节点表就是用来直到一个节点到另一个节点是走的哪条路，例如C到D，前驱节点是F；而C到F前驱节点是E；C到E前驱节点是C，说明了C到D就是走的CEFD。

## 马踏棋盘算法

![image-20211123161522807](C:\Users\10277\AppData\Roaming\Typora\typora-user-images\image-20211123161522807.png)





# 安排



回溯（90）、union/find		1天

动态规划：3天



稀疏数组

队列

单列表

双向链表

栈

前缀、中缀、后缀表达式

递归

排序：冒泡、选择、希尔、**插入、快排、归并、基数**

查找：二分、插值、斐波那契查找

哈希表

