## 1.1 信息就是位+上下文

hello.c文件：

```c
1 #include <stdio.h>
2
3 int main()
4 {
5         printf(“hello,world\n”);
6 }
```

源程序是一个文本文件。源程序都是由0和1组成的位（bit）序列，而这些序列代表的文本字符都是通过ASCII标准来表示的。实际上就是用一个唯一的单字节大小的整数值来表示每个字符。

![1-1-1](E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-1-1.png)

上面的hello.c就是一个只由ASCⅡ码构成的文件成为**文本文件**，所有其他文件都称为**二进制文件**。

系统中所有的信息———包括磁盘文件、存储器中的程序、存储器中存放的用户数据以及网络上传送的数据，都是由一串位表示的。区分不同数据对象的唯一方法是我们读到这些数据对象时的**上下文**。  

从机器码层说明一下：
比如内存中的二进制信息  

	1000100111011000   

计算机可以把它当做数据处理也可以当作指令来执行  

	1000100111011000  ——> 89D8H(数据)      
	1000100111011000  ——> mov ax,bx(程序)

决定是指令还是数据的判断：传输总线的类型 。

当然这里的数据和指令都属于前面说的位   



## 1.2  程序被其他程序翻译成不同的格式 

 hello程序的生命周期是从高级C语言程序开始，然后为了在系统上运行该程序，须被其他程序转化为低级的机器语言指令，而存储程序的格式是二进制磁盘文件。

![1-2-1](E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-2-1.png)

### 1.预处理阶段

  预处理阶段，预处理器cpp会根据#开头的命令，修改原始的C程序。因为hello.c代码中只包括了文件包含命令，所以程序只把stdio.h的内容插入到源程序中。

主要的预处理命令有：

![1-2-2](E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-2-2.png)

**第一类：文件包含**

文件包含包括#include <xxx.h>和#include "xxx.h"

<p>#include <xxx.h> 表示被包含的文件在系统目录
<p>#include "xxx.h"    表示被包含的文件在引号里面的目录，如果没路径则表示为当前目录。


对于自己写的头文件，适合用双引号，系统头文件两个都可用，但尖括号免去了在用户目录搜索。

在预处理阶段，预处理器把包含的头文件的内容展开到源文件中。

### 2.编译阶段

在编译阶段，编译器(ccl)会将文本文件hello.i翻译成文本文件hello.s,它包含一个**汇编语言程序**。这个是以后章节的重点，在这里就不多说了。

gcc在处理程序的流程：

<img src="E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-2-3.png" />

gcc -S 就会生成汇编代码。

### 3.汇编阶段

在汇编阶段，汇编器(as)将hello.s翻译成机器语言指令，打包到hello.o

```
root@kali:~/Desktop/c/csapp/chapter1# as  -o hello.o hello.s
root@kali:~/Desktop/c/csapp/chapter1# file hello.o
hello.o: ELF 32-bit LSB relocatable, Intel 80386, version 1 (SYSV), not stripped
```

### 4.链接阶段

链接器(ld)负责处理hello.o和调用函数的.o文件合并，得到可执行文件hello



## 1.3 处理器读并解释存储在存储器中的指令

### 硬件

总线，I/O设备，主存，处理器等介绍略过。主要是下面的这个图：

<img src="E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-4-1.png" >

### 运行程序的流程

就是将文件从一个地方搬运到另一个地方。

<img src="E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-4-2.png" >

- 键盘 　 shell得到键盘的输入  

<img src="E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-4-3.png" >

- shell　  shell执行指令将目标文件代码和数据从磁盘加载到内存  

<img src="E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-4-4.png" >

- 处理器 　目标程序的机器语言代码复制到处理器执行，结果存储在寄存器中并复制到显示设备在屏幕显示  

## 1.4 高速缓存至关重要

### 高速缓存

在运行程序的过程中，发现一个很重要的问题：系统花费了大量的时间把信息从一个地方挪到另一个地方。  

在1.3的实例中：hello程序的机器指令开始是放在磁盘上  

- 程序加载时，它们被复制到主存(从磁盘到内存)
- 程序运行时，它们被复制到处理器(从内存到处理器)

"hello, world\n"数据最开始在磁盘，后来复制到内存，然后是显示设备。  

这些复制就是开销，减缓了程序的工作。怎么才能使这些复制工作尽快完成呢？    
处理器和内存的速度差异非常大，系统设计者采用了更小、更快的存储设备，即高速缓存存储器（简称高速缓存），作为暂时的集结区域，用来存放处理器近期可能会需要的信息。  

<img src="E:/深入理解计算机系统笔记/CSAPP-note/Chapter01/image/1-5-1.png" >

现在较新的系统都有三级高速缓存：L1、L2和L3。  

为什么需要n级缓存呢？  
因为系统可以获得一个很大的存储器，同时访问速度也很快，原因是利用了高速缓存的局部性原理，即程序具有访问局部区域里的数据和代码的趋势。通过让高速缓存里存放可能经常访问的数据的方法，大部分的存储器操作都能在快速的高速缓存中完成。  

意识到高速缓存存在的应用程序员可以利用高速缓存将他们程序的性能提高一个数量级。

## 1.5 存储设备形成层次结构

实际上，每个计算机系统中的存储设备都被组织成了一个存储器层次结构，下图所示：

<img src="E:/深入理解计算机系统笔记/CSAPP-note/Chapter01/image/1-6-1.png" >

存储器层次结构的主要思想是一层上的存储器作为低一层存储器的高速缓存。因此，寄存器文件就是L1的高速缓存，L1是L2的高速缓存，L2是L3的高速缓存，L3是主存的高速缓存，而主存又是磁盘的高速缓存。在某些具有分布式文件系统的网络系统中，本地磁盘就是存储在其他系统中磁盘上的数据的高速缓存。  

可以运用不同的高速缓存的知识来提高程序性能一样，程序员同样可以利用对整个存储器层次结构的理解来提高程序性能。  



## 1.6 操作系统管理硬件

### 操作系统基本功能

- 防止硬件被失控的应用程序滥用
- 向应用程序提供简单一致的机制来控制复杂而又通常大相径庭的低级硬件设备

操作系统通过几个基本的抽象概念（进程、文件、虚拟内存）来实现上述两个功能。

### 进程

- 进程是操作系统对一个正在运行的程序的一种抽象。

关于上下文切换：   
上下文：操作系统保持跟踪进程运行所需的所以状态信息。例如：PC，寄存器，内存内容等    
上下文切换：当操作系统决定把控制权从当前进程转移到某个新进程时，就会进行上下文切换，保持当前进程的上下文，恢复新进程的上下文并将控制权转移给新进程。  
如下图所示：

 <img src="E:/深入理解计算机系统笔记/CSAPP-note/Chapter01/image/1-7-1.png" >

进程的详细内容会在以后介绍。

### 线程

一个进程实际上可以由多个线程执行单元组成，每个线程都是运行在进程的上下文中，并共享同样的代码和全局数据。  
书上提到网络服务器对并行处理的需求，线程成为越来越重要的编程模型，因为多线程之间比多进程之间更容易共享数据，也因为线程的一般来说都比进程更高效。  网络编程的模型，可以参考《UNP卷一》的总结和陈硕的这一篇博文——[多线程服务器的常用编程模型](http://blog.csdn.net/solstice/article/details/5307710)。  

线程以后会详细谈。  

### 虚拟存储器

虚拟存储器是一个抽象概念，它为每个进程提供了一个假象，即每个进程都在独占地使用主存。每个进程看到的是一致的存储器，称为虚拟地址空间。  
以图说明：

 <img src="E:/深入理解计算机系统笔记/CSAPP-note/Chapter01/image/1-7-2.png" >

- 程序代码和数据 
  对于所有的进程来说，代码是从同一固定地址开始，紧接着的是和C全局变量相对应的数据位置。  
  其实程序和数据都是有exec从程序文件中读入的。  
  它包括正文段，数据段和bss段。  
  - 正文段(.text段)：由CPU执行的机器执行部分，可共享，在存储器中只需要一个副本，只读。只读是为了防止程序修改自身的指令。 

  - 数据段(.data段)，也称初始化数据段。它包含了程序中需要明确赋值的变量。例如：初始化了的全局变量。  

  - bss段(.bss段)，也称未初始化段。在程序开始之前，内核将此段的数据初始化为0或者空指针，例如：未初始化的全局变量   

- 栈   
  自动变量和每次函数调用时所需要保持的信息都放在此段中。每次调用函数时，其返回地址以及调用者的环境信息都会存放在栈中，然后，最近被调用的函数在栈上为自动和临时变量分配空间。(递归函数调用自身的时候，会使用新的栈，所以变量不受影响)

- 堆  
  运行时堆。代码和数据区是在进程一开始运行时就被规定了大小，与此不同，当调用如malloc和free这样的C标准库函数时，堆可以在运行时动态地扩展和收缩。  

- 共享库  
  一块用来存放像C标准库和数学库这样共享库的代码和数据的区域。动态链接库的好处，以后详细说明。  

- 内核虚拟存储器  
  内核总是驻留在内存中，是操作系统的一部分。地址空间顶部的区域是为内核保留的，不允许应用程序读写这个区域的内容或者直接调用内核代码定义的函数。这个区域会存储命令行参数和环境变量。

最后，我们来看看hello的正文段，数据段和bss段的大小：

    root@kali:~/Desktop/c/csapp/chapter1# size hello
       text    data     bss     dec(十进制)     hex(十六进制)   filename
        328     176       0     504 (总长度)     1f8(总长度)     hello

hello程序不使用动态库编译之后大小：

    root@kali:~/Desktop/c/csapp/chapter1# gcc -static hello.c
    root@kali:~/Desktop/c/csapp/chapter1# size a.out
       text    data     bss     dec     hex filename
     565988    4004    4988  574980   8c604 a.out

使用动态库编译之后大小：

    root@kali:~/Desktop/c/csapp/chapter1# gcc hello.c
    root@kali:~/Desktop/c/csapp/chapter1# size a.out
       text    data     bss     dec     hex filename
       1150     288       4    1442     5a2 a.out

### 文件
文件就是字节序列。  
每个I/O设备，包括磁盘、键盘、显示器，甚至网络，都可以视为文件。系统中的所有输入输出都是通过使用一小组称为UnixI/O的系统函数调用读写文件来实现的。

有兴趣的研究一下linux下的/proc文件夹。



## 1.8 系统之间利用网络通信

我们可以认为网络也是一种I/O设备。  
使用telnet在远程机器上运行hello流程图如下：

 <img src="E:/深入理解计算机系统笔记/CSAPP-note/Chapter01/image/1-8-1.png" >

当我们在telnet客户端键入“hello”字符串并敲下回车键后，客户端软件就会将这个字符
串发送到telnet的服务器。telnet服务器从网络上接收到这个字符串后，会把它传递给远端外壳程序。接下来，远端外壳运行hello程序，并将输出行返回给telnet服务器。最后，telnet服务器通过网络把输出串转发给telnet客户端，客户端就将输出串输出到我们的本地终端上。  
这是典型的C/S程序交互的过程。  

书中并没有telnet的连接过程，这里介绍一下。  
telnet协议是应用层协议，用于远程登录。    
它使用TCP协议来连接远程主机，本地终端输入的字符全部以NVT格式明文传送，然后远程主机的输出也会以NVT格式传输并转化为本地格式，显示在本地终端上。    

对TCP协议不熟悉的可以看看《TCP/IP卷一》并用tcpdump抓包分析分析。



## 1.9 重要主题

### Amdahl定律

书上16页

### 并发和并行

并发：一个同时具有多个活动的系统  
并行：用并发使一个系统运行得更快  

- 线程级并发
  单处理器系统，一个CPU，进程间快速切换的方式实现  
  多处理器系统，多个CPU,要求程序运行更快，就需程序多线程
  超线程，允许一个CPU执行多个控制流的技术  

- 指令集并行
  处理器可以同时执行多条指令
  超标量处理器：处理器可以达到比一个周期一条指令更快的执行速率  

- 单指令，多数据并行
  许多现代处理器拥有特殊的硬件，允许一条指令产生多个可以并行执行的操作，这种方式称为单指令、多数据 ，即SIMD并行

### 抽象

计算机系统中的抽象：
如图：

<img src="E:\深入理解计算机系统笔记\CSAPP-note\Chapter01\image\1-9-1.png" >

- 文件是对I/O的抽象
- 虚拟存储器是对程序存储器的抽象
- 进程是对一个正在运行程序的抽象
- 虚拟机是对整个计算机的抽象

导图：https://data2.liuin.cn/story-writer/2018_1_24_A%20Tour%20of%20Computer%20System.png 

