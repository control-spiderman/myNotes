# 信息的表示和处理

此处研究三种最重要的数字表示：

- 无符号编码：基于传统的二进制编码方法，表示大于等于0的数字。
- 补码编码：表示有符号整数的最常见方式。
- 浮点数编码：表示实数的科学计数法的以2为基数的版本。

计算机采用这些不同的表示方法来实现算术运算。

## 1.1 信息存储

大部分计算机使用8位的块（或者字节）来作为最小的可寻址的存储器单元。机器级程序将存储器视为一个非常大的字节数组，称之为虚拟存储器。存储器中的每一个字节由唯一的一个地址（address）来标识，所有可能地址的集合称之为虚拟地址空间（virtual address space）。

接下来几章会讲解编译器和运行时系统是怎样将存储空间划分为更可管理的单元，来存储不同的程序对象。即程序、指令、数据和控制信息。

>指针是c语言中的一个特性，指针有两个方面：值和类型。值用来存储指针所指向的数据的地址，类型是其所指向数据的类型。

### 十六进制表示法

一个字节有8位，用二进制表示就是 \00000000(2)-11111111(2) ，用十进制表示是0(10)-256(10)，用十六进制表示是00(16)-FF(16)。

- 之所以用十六进制就是因为二进制的表示太冗长，而十进制与二进制的转化又太麻烦。

- 在c语言中，以0x或0X开头的就表示为十六进制。

### 字数据大小

每台计算机都有一个字长（word size），指明整数和指针数据的标称大小（nominal size），字长决定系统中最重要的参数就是虚拟地址空间的最大大小

计算机和编译器使用不同的方式来编码数字，比如说不同长度的整数和浮点数，从而支持多种数据格式
![image-20210908204515417](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210908204515417.png)

程序员应该力图使他们的程序在不同的计算机和编译器上可移植，可移植的其中一个方面就是**使程序对不同的数据类型的确切大小不那么敏感**

### 寻址和字节顺序

多字节对象都被存储为连续的字节序列，对象的地址为所使用字节最小的地址。

对于跨多个字节的程序对象，我们必须建立两个规则：这个对象的地址是什么；我们怎样在存储器中对这些字节进行排序

> 小端法
> 从低有效字节到高有效字节的顺序存储对象

> 大端法
> 从高有效字节到低有效字节的顺序存储对象

对于一个十六进制的数0x01234567：
![image-20210908204906882](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210908204906882.png)

大多是Intel兼容机都只是用小端模式。

### 表示字符串

C中的字符串被编码为一个以null（其值为0）字符结尾的字符数组

### 表示代码

不同的机器类型使用的是不同的并且不兼容的指令和编码方式，所以最后的二进制代码是有很强的平台依赖性的，其很少能够在不同的操作系统和机器之间进行移植

### 布尔代数简介

![image-20210908205448280](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210908205448280.png)

### C中的位级运算

包括按位与、按位或、异或运算，位运算的一个常见应用就是实现掩码运算（从一个字中选出一个组位）

确定一个位级表达式的结果最好的方法，就是将一个十六进制的数据转换成二进制进行位运算，然后再转换成16进制。

### C中的逻辑运算

包括逻辑或（||）、逻辑与（&&）、逻辑非（！）
逻辑运算表达式中，第一个参数能够确定表达式的结果的时候，逻辑运算表达式就不会计算第二个参数的值

### C中的移位运算

向左移位（<<）运算右端补0
向右移位(>>)运算包含两种形式：逻辑移位（左端补0）和算数移位（左端补最高有效位）



## 1.2 整数表示

本节主要描述用位来编码整数的两种方式：无符号编码和补码编码

下图定义了一些数学术语，用于描述一些对整数的编码和操作。

![image-20210908210322454](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210908210322454.png)

![image-20210908210354381](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210908210354381.png)

### 整型数据类型

![image-20210908210531247](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210908210531247.png)

### 无符号和二进制补码编码

对于无符号编码和补码编码的公式看书上44和45页。这部分较简单，简单略过。

假设一共有 w 位，每个介于 0 ~ 2^w -1 之间的数都有唯一一个 w 位的值编码，即这个函数映射是一个双射。

补码表示的是字的最高有效位解释为负权(negative weight)。

### 有符号数和无符号数之间的转换

对于大多数C语言来说，处理同样字长的无符号数和有符号数之间相符转换的规则是：**数字可能会变，位模式不变**

![image-20210908210632927](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210908210632927.png)

C 语言允许无符号数和有符号数之间的转换。转换的原则是**底层的位表示保持不变**。

### 扩展一个数字的位表示

零扩展： 将一个无符号数转换为一个更大的数据类型，在开头加0
符号扩展： 将一个二进制补码转化为一个更大的数据类型，在开头加最高有效位

### 截断数字

截断一个数字可能会改变它的值——溢出的一种形式

### 有关有符号数和无符号数的建议

有符号数到无符号数的隐式强制类型转换导致了某些非直观的行为。而这些非直观的特性经常导致程序错误，并且这种包含隐式强制类型转换细微差别的错误很难被发现。因为这种强制类型转换是在代码中没有明确指示的情况下发生的，程序员经常忽视了它的影响。

避免这类错误的一种方法就是绝**不使用无符号数**。实际上，除了 C 以外，很少有语言支持无符号整数。



## 1.3 整数运算

### 无符号加法

每个数都能表示为 w 位无符号数字。如果计算它们的和，表示这个和可能需要 w + 1位。无符号运算可以被视为一种**模运算形式**。

![image-20210909140626667](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909140626667.png)

**在形式上直接按位运算，当发生溢出时，直接截断溢出位。在含义上，表示对计算的结果减去2^w。**

**无符号数求反：**

对于无符号数x，当x=0时，其无符号逆元就为其本身。当x>0时，其无符号逆元为2^w-x。

### 补码加法

与无符号数加法同样的操作形式。在含义上，**当两数和超过TMax（即正最大值）时，就说明发生了正溢出，截断溢出位后，相当于从和数中减去2^w；当两数和超过TMin（即负最大值）时，说明发生了负溢出，截断溢出位后，相当于从和数中加上了2^w。** 

![image-20210909141503665](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909141503665.png)

下面是一个例子：

![image-20210909141321694](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909141321694.png)

### 补码的非

对于在TMin和TMax之间的每个数字x，都有加法逆元。对于w位的补码加法来说，TMin是自己加法的逆，而对于其他任何数值x都有-x作为其加法的逆。也就是TMin+TMin = -2^w 发生了负溢出，则将结果加上2^w，可得TMin+TMin=0。同理x+（-x）=0

### 无符号乘法

对于在0到(2^w)-1的两个无符号整数，对其做乘法，结果可能需要2w位来表示。

在C语言中将无符号乘法定义为产生w位的值，就是2w位的整数乘积的低w位表示的值。因此，**将一个无符号数截断为w位等价于计算该值模2^w**。

### 补码的乘法

补码的乘法在位操作上与无符号乘法相同，都是相乘之后截断溢出位（取模运算）。不同的只是二进制码表示的数值结果不一样。下面是一个例子：

![image-20210909150525423](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909150525423.png)

### 乘以常数

在大多数机器上，整数乘法指令相当慢，需要 10 个或者更多的时钟周期，然而其他整数运算(例如加法、减法、位级运算和移位)只需要 1 个时钟周期。因此，编译器使用了一项重要的优化，试着用移位和加法运算的组合来代替乘以常数因子的乘法。

对于一个数x，对其位模式向左移k位，低位用k个0来补，得到的新结果就是对数x乘以2^k的结果。再把高k位进行截断，就等同于前面做的乘法操作。

无符号数和补码数具有相同的位操作方式。不同的只是操作完成后的结果。

因此对于乘以任意一个常数，都可以将这个常数表示成2的冥的数据的加减组合，然后再做对应的移位操作。**例如x*14，14=8+4+2。因此编译器可以将乘法重写为(x<<3)+(x<<2)+(x<<1)。**

### 除以2的冥

在大多数机器上，整数除法要比整数乘法更慢——需要 30 个或者更多的周期。除以 2 的幂也可以用移位运算右移来实现，无符号和补码数分别使用逻辑移位和算术移位来达到目的。

整数除法总是舍入到0（近0操作），即大于零时，向下取整；小于零时，向上取整。

**无符号数：**

对于无符号数直接执行逻辑右移操作即可，下面是一个对12340进行除法和逻辑右移操作的例子，可以看出这是近0操作的：

![image-20210909152506886](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909152506886.png)

**补码运算：**

对于除以2的冥的补码运算来说，需要保证负数任然是负数，移位要执行算数右移。如下图所示是一个算数右移的例子：

![image-20210909153239155](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909153239155.png)

从图中可以看出，对于负数（**正数情况不影响**）本应该是向上取整的（即-771，-48），但算术右移产生了这样不正确的情况，因此需要在算数右移前加上一个偏置。即**(x+(1<<k)-1)>>k，左边数值为x+2^k-1**。例子如下所示：

![image-20210909153615635](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909153615635.png)

从上可以看出，对于不需要摄入的情况（k=1），加上偏量只会影响那些被移掉的位，对于需要舍入的情况，加上偏量导致较高的位加一，所以结果会向零舍入。

### 

## 1.4 浮点数

### 二进制小数

![image-20210909155131413](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909155131413.png)

注意，形如0.11…1的二进制数表示的是刚好小于1的数，例如0.111111表示63/64。因此将用简单的表达法1.0-ε来表示这样的值。

小数的二进制法只能表示那些可以写成x*2^k的数，其他值都只能近似，例如1/5可以在十进制中精确的表示为0.2，但在二进制中只能近似表示。

### IEEE浮点表示

用 V = (-1)^s * M * 2^E 的形式来表示一个数：

* 符号(sign) s决定这个数是负数(s=1)还是正数(s=0)，对于数值 0 的符号位解释作为特殊情况处理。
* 尾数(significand) M 是一个二进制小数，它的范围是 1 ~ 2 - ε，或者是 0 ~ 1 - ε。
* 阶码(exponent) E 的作用是对浮点数加权，这个权重是 2 的 E 次幂(可能是负数)

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

* 一个单独的符号位 s 直接编码符号 s。
* k 位的阶码字段 exp = e(k-1)…e(1)e(0) 编码阶码 E。
* n 位小数字段 frac = f(n-1)…f(1)f(0) 编码尾数 M，但是编码出来的值也依赖于阶码字段的值是否等于 0。

下图展示了单精度数值（1、8、32）和双精度浮点格式（1、11、52）的占位情况：

![image-20210909160616942](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909160616942.png)

给定位表示，根据exp的值，被编码的值可以分成三种不同的情况：

![image-20210909161711208](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909161711208.png)

**case1 规格化的值**

在情况一中的规格化的值，阶码字段被解释为**以偏置形式表示的有符号**。也就是，阶码的值为E=e-Bias，其中e就是阶码的位表示，Bias为2^(k-1)-1的偏置值。其位范围e为00…01~11…10，其表示的值范围E为-2^(k-1)-2 ~ 2^(k-1)-1。这里的**k就是阶码的位数**。

其小数字段的二进制小数点在最高有效位的左边，即0.f。尾数定义为M = 1+f。

**case2 非规格化的值**

当阶码全为0时，表示的数时非规格话形式。这种情况下，阶码E=1-Bias，尾数的值即为M=f。

非规格化数有两种用途。

- 提供了一种表示数值0的方法
- 表示那些非常接近于0.0的数

**case3 特殊值**

如图所示，可以表示无穷大和NaN。

#### 例题1

![image-20210909163209440](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909163209440.png)

#### 例题2

将整数表示化为单精度数值:

- 先将整数的二进制表示化为1.xxxxxx*2^e的形式
- 计算偏置位为2^(k-1)-1，（k是阶码位数），然后用偏置加上e可得出阶码的二进制数值
- 在尾数低位添加相应的0，进行拼接即可得到结果

### 舍入

因为表示方法限制类浮点数的范围和精度，浮点运算只能近似地表示实数运算。因此，对于值 x，我们一般想用一种系统的方法，能够找到“最接近的”匹配值，这就是舍入运算的任务。

如何确定舍入方向。常见的舍入方式有：向偶数舍入（也被称为向最接近的舍入，四舍五入）、向零舍入、向下舍入、向上舍入，默认是第一种，其他三种可用于确定上下界。

![image-20210909165226069](C:\Users\User\AppData\Roaming\Typora\typora-user-images\image-20210909165226069.png)

### 浮点运算

浮点加法不具有结合性。浮点乘法在加法上不具备分配性。对于科学计算程序员和编译器编写者来说，这是很严重的问题，即使为了在三维空间中确定两条线是否交叉而写代码这样看上去很简单的任务，也可能成为一个很大的挑战。

### C语言的浮点数

float 和 double。在 int、float 和 double 格式之间进行强制类型转换时，程序改变数值和位模式的原则如下(假设 int 是 32 位的)：

* 从 int 转换成 float，不会溢出，可能被舍入。
* 从 int 或 float 转换成 double，能够保留精确的数值。
* 从 double 转换成 float，可能溢出成为正无穷或负无穷，也可能被舍入。
* 从 float 或者 double 转换成 int，值会向零舍入。例如 1.999 将被转换成 1。